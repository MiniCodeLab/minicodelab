# React desde 0 | Forms

¬°Hola MiniCoder üëã! Estamos ya en el √∫ltimo post del Taller de React desde Cero en el que estamos viendo los conceptos iniciales que hay que saber de esta librer√≠a para hacer una aplicaci√≥n completa.

Hoy nos toca ver formularios, algo muy com√∫n en todo el mundo web y que a veces se convierte en algo tedioso con lo que trabajar... Aunque vamos a mostrarte una forma de conseguir crear formularios din√°micos de forma muy sencilla. Para ello usaremos la librer√≠a `react-hook-form` üöÄ

Esta librer√≠a se convertir√° en una parte importante de tu arsenal, pero antes tenemos que ver c√≥mo crear formularios en React de la forma m√°s tradicional y manual, para que puedas apreciar y te des cuenta del verdadero poder de `react-hook-form`. ¬°Vamos con ello!

Si antes de continuar quieres consultar algo sobre React que hayamos visto en talleres anteriores, aqu√≠ te dejamos los otros art√≠culos:

<ReferencesStack
  links={[
    {
      type: 'internal',
      url: '/feed/react-0-basicos-1',
      title: 'Conceptos b√°sicos de React parte 1'
    },
    {
      type: 'internal',
      url: '/feed/react-0-basicos-2',
      title: 'Conceptos b√°sicos de React parte 2'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-usestate-useeffect',
      title: 'Hooks useState y useEffect'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-useref',
      title: 'Hook useRef explicado al completo'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-custom',
      title: 'Hooks Customizados'
    },
    {
      type: 'internal',
      url: '/feed/react-0-router',
      title: 'React Router y SPA'
    },
    {
      type: 'internal',
      url: '/feed/react-0-usecontext',
      title: 'Hook Context'
    }
  ]}
/>

---

### Creamos un form manejado por estados (controlado)

Una de las direcciones que podemos tomar para crear formularios es manejarlos a trav√©s de estados. Los `input` que gestionamos por medio de un estado ser√°n **controlados** en todo momento (siempre y cuando el valor nunca sea `undefined` o `null`).

Esto, aunque pueda parecer una ventaja, tiene varias desventajas asociadas que podr√≠amos mejorar con lo que hemos aprendido hasta ahora:

- Habr√≠a que crear un `state` para cada campo del formulario, o un `state` m√°s complejo en forma de objeto.
- Provocaremos un `rerender` completo del formulario por cada cambio en cada input, ¬°imagina lo ineficiente que podr√≠a llegar a ser!
- Tenemos que hacer validaciones a mano para absolutamente todo, ¬øy si se nos escapa algo? üò±

```tsx
const StateForm = () => {
  // Creamos un state para cada campo...
  const [username, setUserName] = useState('');
  const [password, setPassword] = useState('');

  // O un state complejo para todos a la vez
  // const [form, setForm] = useState({
  //   username: "",
  //   password: ""
  // });

  const handleSubmit = (e: React.FormEvent) => {
    // Prevenimos que la p√°gina recargue
    e.preventDefault();

    // Haremos un control de error manual...
    if (!password || !username) {
      console.error('Formulario incompleto! ‚ùå');
      return;
    }

    // Gestionamos el payload del form con los states
    const formPayload = {
      username,
      password
    };
    console.log('formPayload vale:', formPayload);

    // Ya podr√≠amos enviar la informaci√≥n a nuestra API
    // sendToMyApi(formPayload)
  };

  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="username">
        <span>Username:</span>
        <input
          id="username"
          name="username"
          onChange={(e) => setUserName(e.target.value)}
          type="text"
          value={username}
        />
      </label>

      <label htmlFor="password">
        <span>Password:</span>
        <input
          id="password"
          name="password"
          onChange={(e) => setPassword(e.target.value)}
          type="password"
          value={password}
        />
      </label>

      <button type="submit">Submit</button>
    </form>
  );
};
```

Este formulario se ver√≠a tal que as√≠, presta atenci√≥n a los logs por consola:

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1647512026/articles/stateform.gif"
  alt="state-form"
/>

---

### Creamos un form manejado por referencias (no controlado)

Otro camino para hacer formularios que quiz√°s te resulte m√°s c√≥modo de aplicar es a trav√©s del hook `useRef`. Como vimos en el taller de `useRef` podemos tomar una referencia de un elemento HTML cualquiera y escucharlo en todo momento. A trav√©s de este proceso podremos escuchar a los inputs de forma adecuada sin provocar un nuevo `render` en cada cambio de estos.

Aun as√≠, seguimos encontrando la desventaja asociada de que tendremos que gestionar los errores completamente a mano, y tendremos que seguir creando muchas referencias (en el ejemplo anterior fueron estados) para todos los `input`.

Este c√≥digo conseguir√° el mismo resultado que el del anterior ejemplo con `useState`, pero de una forma m√°s eficiente:

```tsx
const RefForm = () => {
  // Creamos una referencia para cada input...
  const usernameRef = useRef<HTMLInputElement>(null);
  const passwordRef = useRef<HTMLInputElement>(null);

  const handleSubmit = (e: React.FormEvent) => {
    // Prevenimos que la p√°gina recargue
    e.preventDefault();

    // Conseguimos el valor de los inputs por medio de su ref, que
    // pueden ser null, de ah√≠ que usemos el optional chaining.
    const username = usernameRef.current?.value;
    const password = passwordRef.current?.value;

    // Haremos un control de error manual...
    if (!password || !username) {
      console.error('Formulario incompleto! ‚ùå');
      return;
    }

    // Gestionamos el payload del form con los campos de referencia
    const formPayload = {
      username,
      password
    };
    console.log('formPayload vale:', formPayload);

    // Ya podr√≠amos enviar la informaci√≥n a nuestra API
    // sendToMyApi(formPayload)
  };

  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="username">
        <span>Username:</span>
        <input
          id="username"
          name="username"
          placeholder="MiniCoder"
          // A√±adimos la referencia al input
          ref={usernameRef}
          type="text"
        />
      </label>

      <label htmlFor="password">
        <span>Password:</span>
        <input
          id="password"
          name="password"
          placeholder="*****"
          // A√±adimos la referencia al input
          ref={passwordRef}
          type="password"
        />
      </label>

      <button type="submit">Submit</button>
    </form>
  );
};
```

---

### Utilizamos `react-hook-form` para crear nuestro formulario

A parte de los dos ejemplo anteriores, puedes crear un formulario de la forma que desees, combinarlos, no usar ninguno... Aun as√≠, siempre se har√° complicado manejar un formulario de forma adecuada por muy simple que sea, ya que conlleva un flujo muy din√°mico de la informaci√≥n.

Aunque estos √∫ltimos a√±os han aparecido herramientas mas que adecuadas para enfrentarnos a este problema, la librer√≠a `react-hook-form` est√° a otro nivel frente al resto en el momento de escribir este art√≠culo. Ya sea por su sencillez de uso, buena documentaci√≥n y cantidad de funcionalidades ü¶Ñ.

React Hook Form tiene un enfoque diferente a otras librer√≠as de formularios puesto que adopta el uso de entradas no controladas usando `ref` en lugar de depender de un `state`**.** Seg√∫n la documentaci√≥n nos indica que aumenta el rendimiento de los formularios reduciendo el n√∫mero de renders.

Otras ventajas son el peso de la librer√≠a que no alcanza ni los 9kb, comprimidos con gzip, y podemos a√±adir que React Hook Form sigue los est√°ndares HTML para validar los formularios utilizando una API de validaci√≥n basada en restricciones.

Visita la documentaci√≥n aqu√≠: [https://react-hook-form.com/](https://react-hook-form.com/)

En este art√≠culo vamos a ver las funcionalidades m√°s comunes, y vas a aprender a usar esta librer√≠a de forma adecuada para la gran mayor√≠a de casos que te encuentres üî•

---

### Formulario de autenticaci√≥n con `react-hook-form`

Vamos a comenzar instalando la librer√≠a en nuestro proyecto de React:

```bash
npm i react-hook-form@latest
```

Ahora vamos a limpiar el componente formulario que hemos creado antes:

```tsx
const AuthForm = () => {
  const onFormSubmit = () => {};

  return (
    <form onSubmit={onFormSubmit}>
      <label htmlFor="username">
        <span>Username:</span>
        <input id="username" name="username" placeholder="MiniCoder" type="text" />
      </label>

      <label htmlFor="password">
        <span>Password:</span>
        <input id="password" name="password" placeholder="*****" type="password" />
      </label>

      <button type="submit">Submit</button>
    </form>
  );
};
```

Como puedes ver, el formulario est√° falto de controlar los campos disponibles y la funci√≥n de `submit` de forma adecuada.

Vamos a importar el hook principal de `react-hook-form` que se llamar√° `useForm`, de la siguiente manera al principio del archivo:

```tsx
import { useForm } from 'react-hook-form';
```

Con esto podremos invocar el `hook` en nuestro componente para destructurar las siguientes claves del objeto que devuelve:

```tsx
import { useForm } from 'react-hook-form';

const AuthForm = () => {
  const { handleSubmit, register } = useForm();

  const onFormSubmit = () => {};

  return <form onSubmit={onFormSubmit}>{/* ... */}</form>;
};
```

**¬øC√≥mo funcionan estos valores de `useForm`?**

- `handleSubmit` ‚áí Esta funci√≥n nos permitir√° componer una funci√≥n `submit` que no solamente evita que el formulario recargue la p√°gina, sino que nos proporciona todos los valores del formulario en un objeto formateado, y tambi√©n se encargar√° de hacer las validaciones que configuremos en nuestros inputs.
- `register` ‚áí Esta funci√≥n acepta dos argumentos. El nombre `name` que le daremos al `input` asociado, y un objeto de configuraci√≥n para indicar validaciones y caracter√≠sticas que aplicar al `input`.

Vamos a aplicar estas funciones para que lo veas en c√≥digo üöÄ

```tsx
import { useForm } from 'react-hook-form';

type FormValues = {
  username: string;
  password: string;
};

const AuthForm = () => {
  const { handleSubmit, register } = useForm<FormValues>();

  // Recibimos los valores. dleform en nuestro submit handler
  const onFormSubmit = (values: FormValues) => {
    console.log('Form values:', values);
  };

  return (
    // Envolvemos nuestra funci√≥n de submit con la que nos da la librer√≠a
    <form onSubmit={handleSubmit(onFormSubmit)}>
      <label>
        <span>Username:</span>
        {/* Invocamos register y pasamos sus atributos en un spread */}
        <input {...register('username')} placeholder="MiniCoder" type="text" />
      </label>

      <label>
        <span>Password:</span>
        {/* Invocamos register y pasamos sus atributos en un spread */}
        <input {...register('password')} placeholder="*****" type="password" />
      </label>

      <button type="submit">Submit</button>
    </form>
  );
};
```

Ve√°moslo en acci√≥n con un GIF üé¶:

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1647512026/articles/hookform1.gif"
  alt="hook-form-1"
/>

Ahora toca introducir validaciones para no tener que controlar los valores por nuestra cuenta... ¬øQu√© te parece? Vamos a proponer las siguientes condiciones:

- `username` debe tener al menos 2 caracteres y es requerido.
- `password` debe tener al menos 6 caracteres, conteniendo una min√∫scula, una may√∫scula y un n√∫mero, adem√°s de ser requerido.

Como hemos comentado antes, podemos enviar un objeto de opciones como segundo argumento de `register`, as√≠ que vamos a configurarlo de la siguiente forma:

```tsx
<label>
  <span>Username:</span>
  <input
    {...register("username", {
      required: true, // Validar√° que el campo tenga valor
      minLength: 2 // Validar√° la longitud m√≠nima
    })}
    placeholder="MiniCoder"
    type="text"
  />
</label>

<label>
  <span>Password:</span>
  <input
    {...register("password", {
      required: true, // Validar√° que el campo tenga valor
      minLength: 6, // Validar√° la longitud m√≠nima
    })}
    placeholder="*****"
    type="password"
  />
</label>
```

Ahora podemos comprobar que cuando pulsamos el bot√≥n `Submit` no ocurre nada en nuestra aplicaci√≥n üò±. Adem√°s, nos falta la validaci√≥n especial de los caracteres de la contrase√±a... Esto lo conseguiremos por medio de un objeto o funci√≥n de validaciones que debe devolver `true` para que el input cuente como v√°lido:

```tsx
{...register("password", {
	required: true,
	minLength: 6,
	// Una funci√≥n que devuelve true contar√° como input v√°lido
	validate: () => true
})}

```

Aunque esto es correcto y podr√≠amos hacer la comprobaci√≥n dentro de la funci√≥n, es mejor crear un objeto con funciones para ponerle nombre a nuestro error, ahora lo ver√°s m√°s claro:

```tsx
<label>
  <span>Password:</span>
  <input
    {...register('password', {
      required: true,
      minLength: 6,
      // Prevenimos que haya espacios en la contrase√±a
      pattern: /^\S*$/,
      validate: {
        // Comprobamos que hay may√∫sculas, min√∫sculas y n√∫meros
        format: (password) => {
          return /[A-Z]/g.test(password) && /[a-z]/g.test(password) && /[0-9]/g.test(password);
        }
      }
    })}
    placeholder="*****"
    type="password"
  />
</label>
```

Este `input password` con esta validaci√≥n es totalmente adecuado para un proyecto que necesite usar contrase√±as üëè¬†¬°Puedes quedarte con el ejemplo para el futuro!

Ahora que tenemos todo controlado con respecto a validaciones, `react-hook-form` nos ofrece dos formas distintas de trabajar con errores, ambas pueden coexistir en el mismo componente sin problemas, aunque nosotros nos vamos a centrar en una:

- Objeto `errors` que podemos destructurar de `useForm`, estar√° actualizado seg√∫n ocurran validaciones y el primer submit.
- Funci√≥n `errorHandler` que podemos enviar a `handleSubmit` como segundo argumento, donde haremos algo m√°s de control por nuestra parte.

**Validaci√≥n de formulario por medio de una funci√≥n**

Con la funci√≥n que controlaremos a mano, quedar√≠a un c√≥digo como este:

```tsx
const AuthForm = () => {
  const { handleSubmit, register } = useForm<FormValues>();

  const onFormSubmit = (values: FormValues) => {
    console.log('Form values:', values);
  };

  const onFormError = (errors: any) => {
    console.log('Form errors:', errors);

    // Aqu√≠ podr√≠amos invocar un toast o crear errores de forma manual
  };

  return (
    // Hemos enviado onFormError como segundo argumento
    <form onSubmit={handleSubmit(onFormSubmit, onFormError)}>{/* ... */}</form>
  );
};
```

Con nuestra validaci√≥n, el `console.log` de la funci√≥n `onFormError` se ve de la siguiente forma:

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1647512249/articles/form-error-img.png"
  alt="form-error-img"
/>

C√≥mo puedes ver el objeto `errors` contiene una key para cada campo que haya fallado, en este caso nuestro password no ha cumplido la validaci√≥n que hemos creado y llamado `format`.

Este error contiene un mensaje que podr√≠amos devolver en la validaci√≥n manual que hemos generado, aunque vamos a gestionarlo de otra forma menos enrevesada üëç

**Validaci√≥n de formulario por medio de un objeto `errors`**

Antes te hemos explicado que podemos obtener un objeto `errors` de lo que devuelve `useForm`. Ese objeto tendr√° el mismo formato que el que acabamos de ver en la funci√≥n `onFormError`.

Vamos a mostrarte un ejemplo de c√≥digo d√≥nde controlaremos ese error directamente, recuerda que en el taller en directo y video de youtube podremos hacer m√°s ejemplos en caso de que quieras repasar lo que hayamos visto.

```tsx
type FormValues = {
  username: string;
  password: string;
};

const AuthForm = () => {
  const {
    handleSubmit,
    register,
    // Destructuramos los errores del formulario
    formState: { errors }
  } = useForm<FormValues>();

  const onFormSubmit = (values: FormValues) => {
    console.log('Form values:', values);

    // Gestionamos el submit como nos haga falta...
  };

  return (
    <form onSubmit={handleSubmit(onFormSubmit)}>
      <label>
        <span>Username:</span>
        <input
          {...register('username', {
            required: true,
            minLength: 2
          })}
          placeholder="MiniCoder"
          type="text"
        />

        {/* Mostramos el error si no hay username ya que es requerido */}
        {errors.username ? (
          <p className="error">Este campo es requerido y debe tener al menos 2 caracteres</p>
        ) : null}
      </label>

      <label>
        <span>Password:</span>
        <input
          {...register('password', {
            required: true,
            minLength: 6,
            pattern: /^\S*$/,
            validate: {
              format: (password) => {
                return (
                  /[A-Z]/g.test(password) && /[a-z]/g.test(password) && /[0-9]/g.test(password)
                );
              }
            }
          })}
          placeholder="*****"
          type="password"
        />

        {/* Si hay errores en password mostramos el mensaje */}
        {errors.password ? (
          <p className="error">
            {/* Si es de tipo format avisamos al user, si no, ser√° requerido siempre */}
            {errors.password.type === 'format'
              ? 'La contrase√±a debe contener al menos una may√∫scula, una min√∫scula y un n√∫mero'
              : 'Este campo es requerido y debe tener al menos 6 caracteres'}
          </p>
        ) : null}
      </label>

      <button type="submit">Submit</button>
    </form>
  );
};
```

As√≠ quedar√≠a nuestro formulario completo, estamos controlando todos los casos que nos podemos encontrar:

- Hemos hecho `username` requerido y que tenga al menos 2 caracteres.
- Hemos hecho `password` requerido y que tenga al menos 6 caracteres. Adem√°s validar√° si tiene el formato adecuado con una validaci√≥n personalizada `format`.
- Los errores aparecen de forma din√°mica en el formulario a partir del primer `submit`.
- La informaci√≥n que llega a la funci√≥n `onFormSubmit` estar√° correctamente validada y no tendr√° problemas de formato.

Te dejamos un GIF para que veas como se comportar√≠a los elementos de error en el formulario:

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1647512026/articles/errors.gif"
  alt="errors"
/>

---

### Conceptos de validaci√≥n

Antes de terminar os dejamos algunos conceptos b√°sicos de validaci√≥n por s√≠ quer√©is usarlos y no hab√©is buceado por la librer√≠a de de React Hook Forms. Para aplicar validaciones a un campo, puede pasar par√°metros de validaci√≥n al m√©todo de registro. Los par√°metros de validaci√≥n son similares al est√°ndar de validaci√≥n de formularios HTML existente.

Estos par√°metros de validaci√≥n incluyen las siguientes propiedades:

- `required` indica si el campo es requerido o no. Si esta propiedad se establece en verdadero, entonces el campo no puede estar vac√≠o.
- `minlength maxlength` establecen la longitud m√≠nima y m√°xima para un valor de entrada de cadena min y max establecen los valores m√≠nimo y m√°ximo para un valor num√©rico.
- `type` indica el tipo del input, puede ser `email`, `number`, `text` o cualquier otro tipo de entrada HTML est√°ndar.
- `pattern` usa una expresi√≥n regular para validar el input o elemento de entrada.

Otro aspecto a tener en cuenta es que si queremos usar el `onChange` o `onBlur` tienes que pasar `mode` como una propiedad del Hook.

```jsx
const { register, handleSubmit, errors } = useForm({
  mode: 'onChange'
});
```

---

¬°Y con esto hemos acabado con formularios MiniCoder! No solo eso, sino que hemos llegado al final de todos los conceptos b√°sicos que quer√≠amos ver contigo en el **Taller de React desde Cero** üéâ

Ahora toca lo m√°s importante, haremos una serie de talleres en directo trabajando en una aplicaci√≥n completa en la que aplicaremos todo lo aprendido. En cuanto tengamos el contenido terminado y hayamos trabajado la aplicaci√≥n, subiremos a esta web los links a los videos en un nuevo art√≠culo.

Mientras tanto, te invitamos a repasar todo lo que hemos visto, pasarte por el repositorio de Github con el taller [https://github.com/MiniCodeLab/taller-react-desde-cero](https://github.com/MiniCodeLab/taller-react-desde-cero)

Ha sido un placer terminar este primer taller contigo, te esperamos en los siguientes art√≠culos y talleres, ¬°que el c√≥digo te acompa√±e üßô‚Äç‚ôÇÔ∏è!
