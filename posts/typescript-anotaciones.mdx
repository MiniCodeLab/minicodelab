# TypeScript | Anotaciones

¬°Muy buenas MiniCoder! Este es el primero de una serie de art√≠culos enfocados a aprender TypeScript de una forma r√°pida y eficaz.

Como habr√°s imaginado, la raz√≥n por la que hacemos hincapi√© en TypeScript es porque lo consideramos la soluci√≥n a algunos de los problemas de JavaScript, ya que gracias a sus capacidades de tipado nos permitir√°n desarrollar herramientas y aplicaciones robustas de forma segura, y mejorar√°n nuestro d√≠a a d√≠a como desarrolladores.

En esta primera parte sobre como trabajar con TypeScript vamos a ver conceptos b√°sicos como tipado de variables y funciones, que llamamos anotaciones.

### Anotaciones

Para anotar tipos con Typescript vamos a usar **`:`** como si el valor de una propiedad se tratase, es decir para anotar una variable tendremos que a√±adir su anotaci√≥n de tipo. Vamos a verlo con unos cuantos ejemplos as√≠ nos familiarizamos tambi√©n con algunos tipos.

```tsx
const name: string = 'Mini Code Lab';
const age: number = 30;
```

¬øPara qu√© nos sirven las anotaciones de tipo? Nos ayuda a generar c√≥digo robusto. Si nosotros intentamos introducir un valor que no se corresponde al tipo indicado Typescript nos lo indicar√° como un error de tipo.

```tsx
const name: string = 5; // Error de tipo - no asignable
```

Vamos a repasar los tipos b√°sicos que nos ofrece Typescript para generar nuestras anotaciones.

```tsx
// Boolean
const isDeveloper: boolean = true;

// Number
const integer: number = 1;
const float: number = 1.2;
const exp: number = 1e23;

// String
const name: string = 'Mini Code Lab';
```

Tambi√©n podemos tipar arrays, es decir marcar el contenido que tendr√° nuestra lista. Lo vemos en c√≥digo:

```tsx
const favoriteFoods: string[] = ['üçï', 'üåÆ', 'üç±'];
const favoriteNumbers: number[] = [1, 2, 3];
const booleanList: boolean[] = [true, true, false];

// Se pueden combinar entre si sin importar la posici√≥n:
const foodAndNumbers: (string | number)[] = ['üçï', 'üåÆ', 2, 3];
```

Existen tambi√©n los gen√©ricos, que trabajaremos en profundidad m√°s adelante, pero vamos dejar una peque√±a pincelada. Es otra manera de indicar el tipo de los valores de nuestras variables:

```tsx
const favoriteFoods: Array<string> = ['üçï', 'üåÆ', 'üç±'];
```

Pero qu√© sucede si mi Array tiene diferentes tipos en un orden espec√≠fico, esos casos son conocidos como tupla. En la tupla tenemos que a√±adir los tipos que forma nuestro Array. Vamos con el c√≥digo.

```tsx
const dataList: [number, string] = [34, 'Mini Code Lab']

// No podemos tenerlos en otro orden:
const dataList: [number, string] = ['Mini Code Lab', 34] ‚ùå
```

---

En Typescript contamos con un nuevo tipo que es el Enum, este funciona como un alias a valores de tipo num√©rico. Lo explicamos con c√≥digo:

```tsx
enum AvengersName {
  IronMan, // = 0
  Hulk, // = 1
  SpiderMan, // = 2
  AntMan // = 3
}

// usamos el enum
const name: AvengerName = AvengerName.IronMan;

//Comprobamos el valor
console.log(name); // 0
```

Estos valores del enum nos lo asigna autom√°ticamente pero nosotros lo podemos alterar de la siguiente manera.

```tsx
enum AvengersName {
  IronMan = 1,
  Hulk = 2,
  SpiderMan = 3,
  AntMan = 4
}

// usamos el enum
const name: AvengerName = AvengerName.IronMan;

//Comprobamos el valor
console.log(name); // 1
```

Y por √∫ltimo tambi√©n podemos usar los Enum como alias para **`string`**. En este ejemplo tenemos los nombres de nuestros Avengers como clave y por otro lado como valor el nombre de cada uno de ellos.

```tsx
enum AvengersName {
  IronMan = 'Tony Stark',
  Hulk = 'Bruce Banner',
  SpiderMan = 'Peter Parker',
  AntMan = 'Scott Lang'
}

// usamos el enum
const name: AvengerName = AvengerName.IronMan;

//Comprobamos el valor
console.log(name); // Tony Stark
```

Este caso de uso es muy com√∫n y nos permitir√° tener la informaci√≥n estructurada y segura, similar al `Object Literal Pattern/Expression`.

---

Continuando con nuestros tipos primitivos tenemos a **`null`** y **`undefined`** , en este tipo solo podr√°s tener ese contenido:

```tsx
const uMiniCode: undefined = undefined;
const nMiniCode: null = null;
```

En Typescript podemos usar el tipo **`null`** y **`undefined`** como comod√≠n, es decir se les puede asignar a cualquier otro tipo, aunque no es lo m√°s recomendable.

```tsx
const miniNumber: number = null;
const miniName: string = undefined;
```

Para el tipado de Objetos tenemos la palabra **`object`** , esto nos permite tipar nuestros objetos como object. Aunque no es buena pr√°ctica porque es excesivamente laxo, es decir acepta como v√°lido cualquier tipo de objeto.

Para ser m√°s estricto en el tipado de objetos podemos usar las `interfaces` y `types` que veremos m√°s adelante, o en su defecto, si no importa tanto la estructura exacta del objeto, el tipo `Record`:

```tsx
const miniCoders: object = {};
```

---

Vamos con un par de utilidades que nos ofrece Typescript como son **`void`** y **`never`**, para entenderlo mejor usaremos las funciones as√≠ queda mucho m√°s claro.

```tsx
// Esta funci√≥n no devuelve nada en el return
const sayHello = (): void => {
  console.log('Hello Mini Coders');
};

// Esta funci√≥n nunca conseguir√° hacer un return
const infiniteLoop = (): never => {
  while (true) {}
};
```

En la primera funci√≥n no retornamos ning√∫n tipo de valor y por lo tanto podemos indicar que no tiene retorno, es decir **`void`**. Si nosotros intent√°semos retornar un valor Typescript se quejar√°.

```tsx
// Is not assignable ‚ùå
const sayHello = (): void => {
  return 'Hello Mini Coders';
};
```

El tipo **`never`** por el contrario representa los valores que nunca van a suceder u ocurrir. Como vemos estamos en un bucle infinito y por lo tanto el retorno nunca va a suceder. Si tuviese un `return` nos dar√≠a un error en el check del tipado.

```tsx
// Is not assignable ‚ùå
const infiniteLoop = (): never => {
  while (true) {}
  return 2;
};
```

---

Y por √∫ltimo, encontramos el tipo **`any`**, el cual tambi√©n desaconsejamos porque representa cualquier tipo posible y esto provoca que no tenga sentido usar Typescript. Es realmente una mala pr√°ctica emplear este tipo y siempre debemos buscar una alternativa adecuada.

```tsx
const recoverData = () => {
  /* Hacemos return de cualquier dato */
};
let myData: any = recoverData();

// Podemos reasignar por el valor que queramos ‚ùå
myData = 'Mini Code Lab';
myData = 5;
```

Si se da la situaci√≥n en la que realmente no sabemos que puede devolver una funci√≥n o el tipoo exacto de algo, podemos usar `unknown` para que TypeScript sea capaz de avisarnos si lo empleamos incorrectamente, a diferencia de `any` que podr√° pasar cualquier validaci√≥n:

```tsx
const returnUnknownValue = () => {
  /* Devolvemos algo desconocido */
};
const data: unknown = returnUnknownValue();

// Argument of type 'unknown' is not assignable to parameter of type 'string' ‚ùå
parseInt(data);
```

---

Antes de pasar a conceptos m√°s complejos tenemos que conocer el concepto **`Type Assertion`**.

Imagina que necesitamos pasar el valor obtenido por la funci√≥n del ejemplo anterior a otra funci√≥n, como vemos con `parseInt`, pero falla al ser de tipo `unknown`. Esto podemos solucionarlo si tenemos la seguridad de que esta funci√≥n devuelve un string, realizando `Type Assertion` con la palabra `as`:

```tsx
const data: unknown = returnUnknownValue();

// Esto si pasar√° la validaci√≥n de TypeScript
parseInt(data as string);
```

Aqu√≠ tienes una alternativa para hacer exactamente los mismo con tipado gen√©rico, que veremos m√°s adelante:

```tsx
const data: unknown = returnUnknownValue();

// Esto si pasar√° la validaci√≥n de TypeScript
parseInt(<string>data);
```

Para comprobar nuevamente lo que te acabamos de ense√±ar con este ejemplo, puedes ejecutar el siguiente fragmento de c√≥digo en tu editor:

```tsx
const recoverData = () => {
  return 'Mini Code Lab';
};
let myData: unknown = recoverData();

// Indicamos a Typescript que ser√° un string y lo trate como tal
console.log((<string>myData).substr(1));
```

¬°Pues con esto hemos dado nuestros primeros pasos en Typescript! Nos vemos en el siguiente art√≠culo, en el que aprenderemos a trabajar con `interfaces` para tipar objetos correctamente üöÄ

<ReferencesStack
  links={[
    {
      type: 'internal',
      url: '/feed/typescript-interfaces-y-types',
      title: 'TypeScript | Interfaces y Tipos'
    }
  ]}
/>
