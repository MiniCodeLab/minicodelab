# React desde 0 | React memo

춰Muy buenas MiniCoder! Como ya hemos aprendido en los 칰ltimos art칤culos y talleres, la gran mayor칤a del desarrollo en React a d칤a de hoy conlleva conocer en detalle como funciona el sistema de renderizado y como contorlar nuestros componentes.

Hasta el momento hemos conseguido entender correctamente cu치ndo y c칩mo ocurren los renders, pero ahora toca aprender a controlarlos al completo 游댠

<ReferencesStack
  links={[
    {
      type: 'internal',
      url: '/feed/react-0-basicos-1',
      title: 'Conceptos b치sicos de React parte 1'
    },
    {
      type: 'internal',
      url: '/feed/react-0-basicos-2',
      title: 'Conceptos b치sicos de React parte 2'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-usestate-useeffect',
      title: 'Hooks useState y useEffect'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-useref',
      title: 'Hook useRef explicado al completo'
    }
  ]}
/>

Vamos a profundizar en este control de renderizado utilizando una herramienta incre칤ble llamada **`React.memo`**.

---

## Previniendo rerenders gracias a React.memo

Ya te habr치s encontrado en bastantes ocasiones la necesidad de no renderizar de nuevo un componente aunque cambie el estado del componente padre, 춰pero sigue ocurriendo y no tienes forma de evitarlo! 游땸

Este comportamiento podremos obtenerlo a trav칠s de **`React.memo`**, una funcionalidad de React que permite a nuestros componentes realizar un **`shallowCompare`** de sus props. Esto quiere decir que para cada prop recibida, **nuestro componente comprobar치 si las anteriores y las nuevas (`nextProps`) son exactamente iguales,** y en caso de no serlo, permitir치 un rerender del componente.

Esto puede generar problemas con objetos, arrays y funciones generadas a nivel del componente padre sin estar gestionadas a trav칠s de un estado, ya que para cada render estas se recalcular치n y perderemos la referencia al elemento del render anterior, haciendo in칰til un **`shallowCompare`**.

Vamos a ver un ejemplo de ello para ponerlo en pr치ctica creando una vista donde dar puntuaci칩n a nuestras pel칤culas.

Creamos el componente `Movie.tsx` en el que pintaremos el t칤tulo y puntuaci칩n de la peli:

```tsx
type Props = {
  title: string;
  poster: string;
};

const Movie: React.FC<Props> = ({ title, poster }) => {
  console.log('Renderizando Movie...');

  return (
    <div>
      <h3>{title}</h3>
      <img src={poster} alt={title} width={200} />
    </div>
  );
};

export default Movie;
```

Ahora crearemos otro componente `Review.tsx` donde almacenar una rese침a y su puntuaci칩n, que ser치 din치mica:

```tsx
type Props = {
  title: string;
  score: number;
};

const Review: React.FC<Props> = ({ title, score }) => {
  console.log('Renderizando Review...');

  return (
    <div>
      <p>
        {title} - {score}
      </p>
    </div>
  );
};

export default Review;
```

Y por 칰ltimo, el componente padre tendr치 un state que cambiar치 la puntuaci칩n seg칰n introduzcamos valores en un input:

```tsx
import { useState } from 'react';
import Movie from './MovieComponent';
import Review from './ReviewComponent';
import './styles.css';

export default function App() {
  const [score, setScore] = useState(0);

  return (
    <div className="App">
      <Movie
        title="Guardianes de la Galaxia"
        poster="https://m.media-amazon.com/images/I/61-ndDQWTdL._AC_.jpg"
      />

      <hr />

      <label>Cambia tu puntuaci칩n:</label>
      <br />
      <input type="number" value={score} onChange={(e) => setScore(e.target.valueAsNumber)} />

      <Review
        title="La he disfrutado much칤simo, siempre es un placer ver a los guardianes en acci칩n"
        score={score}
      />
    </div>
  );
}
```

Esto lo veremos de la siguiente forma, f칤jate en que los console.log de cada componente aparecen cada vez que cambia el estado del componente padre:

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1645093968/articles/react-desde-cero-hooks/guardiansnomemo.gif"
  alt="reactmemo-guardiansnomemo"
/>

쯇ero es esto lo que buscamos? Seguro que piensas que idealmente no querr칤amos renderizar nuevamente el componente `Movie` cada vez que cambia el estado, ya que este componente no depende del valor `score`.

Esto es posible gracias a `React.Memo` ya que los props son f치cilmente comparables entre renders, evitando renderizados de m치s, 춰vamos a verlo en acci칩n!

```tsx
import React from 'react';

type Props = {
  title: string;
  poster: string;
};

const Movie: React.FC<Props> = React.memo(({ title, poster }) => {
  console.log('Renderizando Movie...');

  return (
    <div>
      <h3>{title}</h3>
      <img src={poster} alt={title} width={200} />
    </div>
  );
});

export default Movie;
```

Hemos a침adido React.memo como envoltura de nuestro componente, ahora solamente tenemos que ver que ocurre cuando cambiamos el valor del input:

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1645093968/articles/react-desde-cero-hooks/guardianswithmemo.gif"
  alt="reactmemo-guardianswithmemo"
/>

춰Y ya lo tenemos, acabamos de optimizar nuestra aplicaci칩n!

A pesar de lo ventajoso que esto resulta, te recomendamos no abusar del uso de `React.memo` ya que envolver componentes con esta utilidad provocar치 una comprobaci칩n constante de los props, y es posible que inclinemos la balanza hacia el lado equivocado debido a un exceso de comprobaciones que ralentizar치n la aplicaci칩n 丘뒲잺.

Pues tal y como hemos visto, ya sabes optimizar tus componentes para prevenir un exceso de renders que afecten negativamente a tu aplicaci칩n, 춰aunque hay que usarlo con cabeza y 칰nicamente cuando tengamos problemas de rendimiento primero!

Nos vemos en el pr칩ximo art칤culo para aprender `useMemo` y `useCallback` como verdaderos cracks 游댠
