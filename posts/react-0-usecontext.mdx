# React desde 0 | Hooks [Context]

¬°Hola MiniCoder üëã! Ya se acerca el final del taller de React desde 0... as√≠ que vamos a poner toda la carne en el asador y terminar de aprender qu√© herramientas de React, y adicionales, nos ayudar√°n a crear aplicaciones incre√≠bles y capaces de todo.

Si antes de continuar quieres consultar algo sobre React que hayamos visto en talleres anteriores, aqu√≠ te dejamos los otros art√≠culos:

<ReferencesStack
  links={[
    {
      type: 'internal',
      url: '/feed/react-0-basicos-1',
      title: 'Conceptos b√°sicos de React parte 1'
    },
    {
      type: 'internal',
      url: '/feed/react-0-basicos-2',
      title: 'Conceptos b√°sicos de React parte 2'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-usestate-useeffect',
      title: 'Hooks useState y useEffect'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-useref',
      title: 'Hook useRef explicado al completo'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-custom',
      title: 'Hooks Customizados'
    },
    {
      type: 'internal',
      url: '/feed/react-0-router',
      title: 'React Router y SPA'
    }
  ]}
/>

---

### Introducci√≥n

En este art√≠culo hablaremos de Context. Esta es una herramienta proporcionada por el equipo de React para almacenar datos de forma localizada en distintos puntos de nuestra aplicaci√≥n, en lugar de almacenarla en un solo componente con el uso de estados. Aprovechando esto, podremos evitar pasar la informaci√≥n a trav√©s de `props` de componente padre a hijo varios niveles, y conseguiremos conectar cualquier componente a este proveedor de datos llamado Context.

En este esquema te mostramos como funcionar√≠a un caso en el que inyectamos el contexto a nivel componente p√°gina (recuerda las entradas a las rutas de react-router) y consumimos el valor del `Context` desde un componente dos niveles por debajo en el √°rbol de componentes.

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1647279360/articles/react-desde-cero-hooks/context-diagram.png"
  alt="context-diagram"
/>

---

### ¬øCu√°ndo debemos usar Context?

En ocasiones nos preguntaremos cu√°ndo usar Context en nuestra aplicaci√≥n de React, en ocasiones podemos reducirlo a los datos globales que queremos compartir y que no vayan a ser altamente din√°micos. Es decir, Context viene bien para gestionar datos de usuarios autenticados, el tema de color (oscuro o claro, por ejemplo) e incluso el idioma de nuestra aplicaci√≥n.

Idealmente, nuestra aplicaci√≥n estar√° pensada de forma que podremos tener diferentes contextos viviendo en distintos puntos de entrada del √°rbol de componentes y no todos estos estar√°n inyectados en el mismo punto. Si tenemos un contexto para gestionar la autenticaci√≥n, `AuthContext`, este ser√° global seguramente, e inyectado desde `App`. En cambio, si tenemos un contexto para gestionar un formulario de m√∫ltiples pasos, `MultiStepFormContext`, este se inyectar√° en el punto de entrada del componente formulario.

---

### ¬øC√≥mo se comporta Context?

Hay que tener cierto cuidado al utilizar `Context`, de forma que no tomemos por costumbre aplicarlo en cualquier punto de la aplicaci√≥n. Esto se debe a varias caracter√≠sticas de esta herramienta:

- El env√≠o de informaci√≥n ahora puede saltarse componentes intermediarios, esto es una gran ventaja que puede verse afectada negativamente si compartimos informaci√≥n por medio de contextos muy gen√©ricos, ya que perderemos la capacidad de seguir adecuadamente el flujo de la informaci√≥n al leer nuestro c√≥digo.
- Elige bien el punto en el que introduces el contexto. Al final, tendremos que proveer a este contexto de un valor din√°mico (en la mayor√≠a de los casos), esto ser√° gestionado por medio de un `useState` o `useReducer` a nivel del `Context`. Y como has visto anteriormente, el cambio que hacemos en un estado acaba pidiendo un nuevo render a React. ¬°Cuidado con los renders sin control!

---

Ahora que hemos le√≠do sobre `Context` y conocemos su apartado te√≥rico y caracter√≠sticas, vamos a hacer un par de ejemplos para aprenderlo con pr√°ctica real üí™

### Control de tema (claro u oscuro) en nuestra app

Vamos a usar `Context` para crear un "switcher" de temas en nuestra aplicaci√≥n. Para ello lo primero que haremos es crear un peque√±o proyecto en el que poner en pr√°ctica los conceptos sobre los que vamos a trabajar.

Para empezar tendremos que crear una carpeta llamada `context` en nuestra carpeta `src`, al igual que hicimos con los componentes y su carpeta `components`. En ella a√±adiremos un nuevo archivo llamado `ThemeContext.jsx` dentro del que crearemos el contexto:

```tsx
import { createContext } from 'react';

// Creamos un type para representar los valores a compartir en el contexto...
export type ThemeContextType = {
  dark: boolean;
  toggle: () => void;
};

// Invocamos a createContext() con los valores iniciales que tendr√° el contexto...
export const ThemeContext = createContext<ThemeContextType>({
  dark: false,
  toggle: () => {}
});
```

---

### ¬øQu√© hace createContext?

Esta funci√≥n de React nos permite generar un nuevo contexto, es decir, un elemento transversal en nuestra aplicaci√≥n que nos ayuda a la hora de compartir informaci√≥n entre componentes en distintos puntos de la aplicaci√≥n. Es un valor reactivo que actua, por decirlo de alguna forma, como una variable global pero con la particularidad de que puede ser modificada y ser√° escuchada por nuestros componentes de una forma similar a `useState`.

---

### Control de tema en nuestra app

Ahora que tienes una idea m√°s clara de todo esto, y has visto un caso sencillo de uso, vamos a crear un Context para gestionar el Theme de nuestra aplicaci√≥n de forma adecuada üöÄ

Vamos a crear el mismo archivo del ejemplo anterior en `src/context/ThemeContext.ts` en el que a√±adiremos un `Context` algo m√°s controlado y definido:

```tsx
import { createContext } from 'react';

// ¬°Ahora haremos el valor de theme m√°s estricto!
export type Theme = 'light' | 'dark';
export type ThemeContextValue = {
  theme: Theme;
  toggleTheme: () => void;
};

export const ThemeContext = createContext<ThemeContextValue>({
  theme: 'light',
  toggleTheme: () => {}
});
```

Ahora inyectaremos el nuevo contexto `ThemeContext` en el componente `App`, ya que al ser un contexto global nos interesa acceder desde el punto m√°s alto de nuestra aplicaci√≥n.

Esto significa que `App` se encargar√° de la l√≥gica del contexto por ahora, ya que debe a√±adir un `value` controlado al `ThemeContext.Provider` que usaremos para envolver nuestro √°rbol de componentes üå≥

```tsx
import { useState } from 'react';
import Header from './components/Header';
import { ThemeContext, Theme } from './context/ThemeContext';

export default function App() {
  const [theme, setTheme] = useState<Theme>('light');

  // Esta funci√≥n cambiar√° entre temas de forma sencilla al invocarla
  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      <div className="App">
        <Header />
      </div>
    </ThemeContext.Provider>
  );
}
```

El componente `Header` ser√° un componente que mostrar√° unos links de navegaci√≥n (de `react-router-dom`) y un filtro de b√∫squeda (que no usaremos ahora). Junto a esto a√±adiremos el bot√≥n para cambiar entre temas `light` y `dark`.

```tsx
import { useContext } from 'react';
import { Link, NavLink } from 'react-router-dom';
import { ThemeContext } from '../context/ThemeContext';
import ThemeSwitcher from './ThemeSwitcher';

const Header = () => {
  const { theme } = useContext(ThemeContext);

  return (
    // Interpolamos theme en la clase para obtener header-light o header-dark
    <header className={`header header-${theme}`}>
      <nav>
        <Link to="/">
          <img
            alt="logo"
            src="https://www.minicodelab.dev/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flonglogo.08a70b46.png&w=256&q=75"
            width={180}
          />
        </Link>

        <NavLink to="/">Home</NavLink>
        <NavLink to="/about">About</NavLink>
      </nav>

      <div>
        <ThemeSwitcher />

        <form>
          <input type="text" placeholder="Search" />
          <button type="submit">Search</button>
        </form>
      </div>
    </header>
  );
};
```

¬øTe has fijado en c√≥mo accedemos al contexto? Utilizamos un hook `useContext` al que pasaremos el contexto al que queremos acceder, en este caso `ThemeContext`. Esto recoger√° los valores almacenados en el contexto, por lo que destructuramos la propiedad `theme` que hemos pasado al `Provider` como `value={{ theme, toggleTheme }}` en `App` ü§Ø.

Este valor ser√° reactivo, lo que significa que al cambiar este, todos los componentes que utilicen el valor se renderizar√°n de nuevo para actualizarse de forma adecuada.

Ahora veremos el componente `ThemeSwitcher` para cerrar la l√≥gica de este ejemplo para cambiar el tema de nuestra aplicaci√≥n:

```tsx
import { useContext } from 'react';
import { ThemeContext } from '../context/ThemeContext';

const ThemeSwitcher = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <button className="theme-button" onClick={toggleTheme}>
      <span>{theme === 'dark' ? 'üåû' : 'üåö'}</span>
    </button>
  );
};
```

¬°Que sencillo! Con esto ya tenemos un bot√≥n que al pulsarlo, provocar√° un cambio del `theme`. Como has podido ver antes en el componente `Header` hemos creado una clase `nav-light` o `nav-dark` que cambiar√° de forma din√°mica... Con un poquito de CSS correctamente gestionado, podemos usar clases din√°micas para conseguir esto:

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1647279360/articles/react-desde-cero-hooks/toggle-context.gif"
  alt="context-diagram"
/>

---

### Bonus: Guardar preferencias en navegador y mejorar la arquitectura

Con el ejemplo que hemos hecho, tenemos en `App` toda la l√≥gica de nuestro contexto. Aunque para una aplicaci√≥n sencilla esto no deber√≠a importar mucho, en el momento en que crezca vamos a tener problemas para controlar el c√≥digo.

Vamos a crear un componente encargado de envolver a una parte de nuestra aplicaci√≥n que ser√° el encargado de almacenar la l√≥gica y el `Provider` de nuestro contexto. De esta forma ser√° m√°s f√°cil localizar y mejorar nuestro `Context` con nuevas aplicaciones.

Vamos a modificar el archivo `src/context/ThemeContext.ts` y a√±adiremos un componente `ThemeContextProvider` de forma que quede as√≠:

```tsx
import { createContext } from 'react';

// ¬°Ahora haremos el valor de theme m√°s estricto!
export type Theme = 'light' | 'dark';
export type ThemeContextValue = {
  theme: Theme;
  toggleTheme: () => void;
};

export const ThemeContext = createContext<ThemeContextValue>({
  theme: 'light',
  toggleTheme: () => {}
});

// Hemos traido aqu√≠ la l√≥gica que hab√≠amos creado en App
export const ThemeContextProvider = ({ children }: { children: React.ReactNode }) => {
  const [theme, setTheme] = useState<Theme>('light');

  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  return <ThemeContext.Provider value={{ theme, toggleTheme }}>{children}</ThemeContext.Provider>;
};
```

De esta forma, el component `App` estar√° m√°s libre y ser√° m√°s f√°cil gestionar vistas y l√≥gica en el punto de entrada de la aplicaci√≥n:

```tsx
const App() {
  return (
    <ThemeContextProvider>
      <div className="App">
        <Header />
      </div>
    </ThemeContextProvider>
  );
}

export default App;√è
```

Como √∫ltimo paso, vamos a darle un toque m√°s profesional a nuestro contexto y haremos que la preferencia de nuestros usuarios por el modo de color permanezca entre recargas de la p√°gina.

Para esto, a√±adiremos un `useEffect` que escuche a `theme` y almacene su valor en `localStorage` de forma din√°mica, para tener siempre disponible el √∫ltimo seleccionado.

Aparte, inicializaremos el `state` del theme utilizando una funci√≥n, que como ya vimos en el art√≠culo sobre `useState` permite a√±adir un valor inicial al estado a trav√©s de un c√≥digo algo m√°s complejo:

```tsx
export const ThemeContextProvider = ({ children }: { children: React.ReactNode }) => {
  // Inicializamos el state por medio de una funci√≥n, haciendo que su
  // valor inicial dependa del almacenado en localStorage si existe
  const [theme, setTheme] = useState<Theme>(() => {
    const initialTheme = window.localStorage.getItem('colorTheme') as Theme;
    return initialTheme || 'light';
  });

  // Cada vez que theme cambie, lo almacenamos en localStorage para siguientes recargas
  useEffect(() => {
    window.localStorage.setItem('colorTheme', theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  return <ThemeContext.Provider value={{ theme, toggleTheme }}>{children}</ThemeContext.Provider>;
};
```

¬°Y con esto conseguiremos que el tema de los usuarios permanezca aunque cierren y abran el navegador!

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1647279361/articles/react-desde-cero-hooks/context-localstorage.gif"
  alt="context-diagram"
/>

---

¬øQu√© te ha parecido? Es bastante m√°s sencillo de lo que parec√≠a al principio entre tanta teor√≠a üíÉ Ahora sabes como funciona `Context` y la comunicaci√≥n entre componentes a trav√©s de esta herramienta.

Vamos a crear un ejemplo m√°s en otro art√≠culo separado (es bastante m√°s complejo üò±) en el que combinaremos varios `Context` con rutas y l√≥gica de `React Router` donde nos har√° falta aprender conceptos m√°s profundos de comunicaci√≥n y arquitectura en `React`.

Gracias por leer otro de nuestros art√≠culos y seguir aprendiendo con nosotros MiniCoder ‚ô•, ¬°queda poco para dominar React!
