# High Order Components (HOC)

¬°Hola MiniCoder üëã! Hoy volvemos con un nuevo art√≠culo enfocado en React, en el que explicaremos uno de los patrones m√°s conocido a la hora de crear aplicaciones escalables y mantenibles con una correcta organizaci√≥n del c√≥digo. Al concepto que vas a aprender en este art√≠culo le llamamos HOC, que para entendernos ser√≠a un "componente de orden superior".

Para definir un HOC, podr√≠amos decir que se trata de un componente cuya √∫nica labor es la de envolver a otro componente y devolverlo de forma consistente, pero a√±adiendo un comportamiento adicional de forma controlada y esperable. Por as√≠ decirlo, a√±ade funcionalidad en un nivel intermedio entre el que ser√≠a el "parent component" y un "child component" de forma que podremos abstraer l√≥gida y no llenar nuestros componentes de condiciones ‚ú®.

---

### Crea tu primer HOC

Ahora que tenemos la definici√≥n de lo que es un HOC, vamos a verlo en c√≥digo para entener el concepto y aprender a usarlo en las situaciones necesarias.

Lo primero que tienes que tener en cuenta es que un HOC se llamar√° normalmente con la palabra `With` seguido de la funcionalidad que estamos a√±adiendo, por ejemplo, un HOC que hace un console.log con el nombre del componente que envuelve, se llamar√≠a `WithComponentNameLog`:

```jsx
const WithComponentNameLog = (Component) => {
  console.log('HOC invocado con el componente:', Component.name);

  return (props) => {
    return <Component {...props} />;
  };
};
```

Como puedes ver, aqu√≠ tenemos un concepto muy importante en marcha, la currificaci√≥n de nuestros componentes, lo que trataremos en otro art√≠culo hablando del concepto `curry` en JavaScript. En resumen, esto consiste en crear funciones que al ser invocadas devuelven otra funci√≥n lista para invocarse üéÅ.

En este caso, la funci√≥n `WithComponentNameLog` recibe un `Component` como argumento, hace un `console.log` con su nombre al ser invocada y devuelve un nuevo componente intermedio que simplemente devuelve a `Component` con los props que se le pasan.

Parece una locura as√≠ de primeras, pero este tipo de conceptos es muy bueno conocerlos para ocasiones futuras y seguramente lo encuentres aplicado en multitud de proyectos, vamos a ver el uso de este HOC en pr√°ctica.

Tendremos un archivo `hocs/WithComponentNameLog.jsx` que exporta el HOC que hemos creado:

```jsx
// Tenemos un HOC que al ser invocado hace un log con el nombre del componente
const WithComponentNameLog = (Component) => {
  console.log('HOC invocado con el componente:', Component.name);

  return (props) => {
    return <Component {...props} />;
  };
};

export default WithComponentNameLog;
```

Tendremos un archivo `components/HomePage.jsx` que exporta un componente `HomePage` muy sencillo:

```jsx
// Tenemos un componente HomePage que queremos envolver en el HOC
const HomePage = () => <h1>Home üè†</h1>;

export default HomePage;
```

Y por √∫ltimo en `App.jsx` vamos a importar todo y a generar un componente `HomePage` vitaminado con ayuda del HOC:

```jsx
import HomePage from './components/HomePage';
import WithComponentNameLog from './hocs/WithComponentNameLog';

// Siempre FUERA DEL RENDER de un componente, envolvemos al componente que queremos en un HOC
const HomeWithLog = WithComponentNameLog(HomePage);

const App = () => {
  return (
    <div className="App">
      {/* Ahora podemos invocar al componente HomeWithLog directamente como si fuese HomePage */}
      <HomeWithLog />
    </div>
  );
};
```

Y esta ser√≠a la forma de utilizar un HOC, la l√≠nea en la que lo invocamos pas√°ndole el componente que queremos envolver, se invocar√° a su vez la primera parte de la funci√≥n `WithComponentNameLog` y esto har√° que veamos por consola:

```bash
HOC invocado con el componente HomeWithLog
```

---

### Casos de uso reales de un HOC

Vale, ahora que has visto en qu√© consiste un HOC y la forma de aplicarlos, vamos a ver un caso de uso real que tenga bastante m√°s sentido que el HOC que hace `console.log` que acabamos de ver üòÇ.

Imagina que tienes tu web personal llena de secciones con t√≠tulos y descripciones, y has creado una animaci√≥n por medio de CSS para que √∫nicamente las secciones que tu quieras cambien de colores como un arcoiris üåà.

```css
.color-swap {
  animation-name: colorSwap;
  animation-duration: 1000ms;
}

@keyframes colorSwap {
  0% {
    color: red;
  }
  25% {
    color: orange;
  }
  50% {
    color: yellow;
  }
  75% {
    color: grey;
  }
  100% {
    color: white;
  }
}
```

Ahora tienes que elegir entre:

- Aplicar este `className` a mano en cada secci√≥n que quieras, envolviendo todo en un `div` al que aplicar la clase y a√±adiendo una l√≥gica a cada componente que realmente no querr√≠as gestionar en ese punto.
- Crear un HOC que gestione esta l√≥gica sobre tus componentes sin alterarlos, teniendo un √∫nico punto de influencia localizado.

Como te puedes imaginar, la segunda opci√≥n es la m√°s viable a largo plazo, as√≠ que vamos a crear un HOC llamado `WithColorSwap`:

```jsx
const WithColorSwap = (Component) => (props) => {
  return (
    <div className="color-swap">
      <Component {...props} />
    </div>
  );
};
```

O su versi√≥n con TypeScript (ya sabes que aqu√≠ nos encanta TS) para que veas como crear HOCs con tipos gen√©ricos:

```tsx
const WithColorSwap =
  <T extends {}>(Component: (props: T) => JSX.Element) =>
  (props: T) => {
    return (
      <div className="color-swap">
        <Component {...props} />
      </div>
    );
  };
```

Como habr√°s podido observar aqu√≠, este HOC es muy sencillo y lo que hace es devolver un componente envuelto en un `div` con la clase `color-swap` aplicada. Podr√≠a tener algo m√°s de l√≥gica para aplicar la clase cuando el componente entre en pantalla para tener transiciones muy din√°micas, pero para este ejemplo no queremos complicar m√°s la cosa üò±

El HOC se usar√≠a de la siguiente forma:

```jsx
// 1. Componente Section que recibe un t√≠tulo y una descripci√≥n, reusable:
const Section = ({ title, description }) => {
  return (
    <section>
      <h1>{title}</h1>
      <p>{description}</p>
    </section>
  );
};

// 2. Creamos un nuevo componente ColorSwapSection que tiene el HOC aplicado a Section
const ColorSwapSection = WithColorSwap(Section);

export default function App() {
  return (
    <div className="App">
      {/** 3. Podemos usar el componente en App como si fuese Section, pero con la animaci√≥n aplicada: **/}
      <ColorSwapSection
        title="MiniCodeLab"
        description="¬øQu√© te parece el contenido de MiniCodeLab? Comp√°rtelo en redes para ayudarnos a crecer en comunidad üöÄ"
      />
    </div>
  );
}
```

Y esto se podr√≠a aplicar a tantos componentes como queramos sin modificar su l√≥gica interna, ver√≠amos lo siguiente en nuestra web:

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1648380349/articles/colorswap.gif"
  alt="color-swap-hoc-gif"
/>

---

### Consideraciones sobre los HOCs

Ahora que has visto un caso de uso real, habr√°s podido observar varias cosas importantes:

- Un HOC puede ser sustituido por un componente que envuelva a nuestro componente sin necesidad de tener funciones currificadas, si te resulta m√°s c√≥moda esta forma de aplicar l√≥gica a tus componentes, no dudes en utilizarla:

```jsx
const WithColorSwap = ({ children }) => {
  return <div className="color-swap">{children}</div>;
};

// Lo usar√≠amos de la siguiente forma, como un componente normal:
export default function App() {
  return (
    <div className="App">
      <WithColorSwap>
        <Section
          title="MiniCodeLab"
          description="¬øQu√© te parece el contenido de
        MiniCodeLab? Comp√°rtelo en redes para ayudarnos a crecer en comunidad
        üöÄ"
        />
      </WithColorSwap>
    </div>
  );
}
```

- Desde que existen los HOOKS en react, podemos crear [Custom Hooks](https://www.minicodelab.dev/feed/react-0-hooks-custom) para aplicar parte de est√° l√≥gica en algunos casos, no dudes en usar patrones que manejes mejor si tienes alternativas üöÄ.

- Un HOC debe ser una funci√≥n lo m√°s pura posible, es decir, para un mismo `input` en las mismas condiciones, debes devolver siempre el mismo output. Si tu HOC a√±ade l√≥giica que depende de un contexto por ejemplo, debes documentarlo correctamente o indicarlo en su nombre.

- Si quieres usar un state o alg√∫n HOOK dentro de la segunda funci√≥n de un HOC, debes crear esa segunda funci√≥n por separado para mejorar la legibilidad, a continuaci√≥n te dejamos un ejemplo bonus (muy √∫til por cierto) para que lo veas aplicado.

Y recuerda MiniCoder üßô‚Äç‚ôÇÔ∏è, este tipo de pr√°cticas y patrones de desarrollo deben aplicarse siempre y cuando el equipo con el que trabajas entienda por qu√© y c√≥mo se aplican, siempre hay alternativas para todas las soluciones que planteamos, por lo que el camino adecuado para tener un proyecto escalable y f√°cil de mantener es estar de acuerdo con el equipo en qu√© pr√°cticas aplicamos.

---

### Bonus HOC: Rutas protegidas y TypeScript

Te dejamos aqu√≠ un √∫ltimo HOC pensado para tener rutas protegidas en React Router v6. Est√° simplificado y no gestiona estados como la carga de datos del usuario, por lo que tendr√°s que ampliarlo si quieres tener la funcionalidad completa.

Como te hemos comentado antes, si un HOC va a utilizar un HOOK en su interior, necesita tener la segunda funci√≥n separada como si fuese un componente para mejorar su comprensi√≥n y lectura. Este HOC se conectar√° a un `Context AuthContext` para cargar un valor `authenticated` que ser√° un booleano, y nos indicar√° si el usuario est√° o no est√° logeado. En caso negativo, har√° una redirecci√≥n a la raiz de nuestra web (podr√≠amos ampliarlo por medio de props).

Definimos primero un contexto para gestionar la autenticaci√≥n:

```tsx
import { createContext } from 'react';

export const AuthContext = createContext(false);
```

Ahora creamos un HOC `WithAuthentication` que proteja nuestras rutas cuando lo apliquemos:

```tsx
import { useContext } from 'react';
import { Navigate } from 'react-router-dom';
import { AuthContext } from '../context/AuthContext';

const WrappedComponent = <T extends { Component: (props: T) => JSX.Element }>(props: T) => {
  const { Component } = props;
  const authenticated = useContext(AuthContext);

  return authenticated ? <Component {...props} /> : <Navigate to="/" />;
};

// HOC para permitir el paso a un componente si estamos autenticados
export const WithAuthentication =
  <T extends {}>(Component: (props: T) => JSX.Element) =>
  (props: T) => {
    return <WrappedComponent {...props} Component={Component} />;
  };
```

Y por √∫ltimo, a√±adimos la l√≥gica de React Router en `App` y aplicamos el HOC a los componentes de que queramos tener en rutas protegidas:

```tsx
import { BrowserRouter, Route, Routes } from 'react-router-dom';
import { AuthContext } from './context/AuthContext';
import { WithAuthentication } from './hocs/WithAuthentication';
import Home from './pages/Home';
import Profile from './pages/Profile';
import './styles.css';

// Componente Profile envuelto por el HOC
const AuthProfile = WithAuthentication(Profile);

export default function App() {
  return (
    <div className="App">
      {/* üö® Cambia este valor entre true/false para probar la ruta protegida üö® */}
      <AuthContext.Provider value={true}>
        <BrowserRouter>
          <Routes>
            <Route index element={<Home />} />

            {/* Usamos una ruta normal, pero con el componente protegido */}
            <Route path="profile" element={<AuthProfile />} />
          </Routes>
        </BrowserRouter>
      </AuthContext.Provider>
    </div>
  );
}
```

Ahora podremos probar la ruta protegida cambiando el valor que proveemos en `App` al `AuthContext.Provider` y veremos como somos redirigidos a la `Home` de la aplicaci√≥n si no tenemos autenticaci√≥n:

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1648381638/articles/redirection-hoc.gif"
  alt="color-swap-hoc-gif"
/>

Te dejamos por aqu√≠ el link al Codesandbox donde tenemos subido el ejemplo por si quieres verlo en un editor online: https://codesandbox.io/s/auth-hoc-9o99y5

---

¬°Esperamos que te haya gustado este art√≠culo! Ahora toca poner todo en pr√°ctica y mejorar nuestro control sobre React y patrones de desarrollo de mayor nivel, gracias por leernos y si puedes compartir estos art√≠culo para crecer juntos no haces un gran favor. ¬°Hasta el pr√≥ximo art√≠culo üéâ!
