# MiniCodeLab

# Taller Next.js - Conceptos b√°sicos

¬°Hola Minicoders! Este ha sido nuestro primer taller en directo, y como lo prometido es deuda, aqu√≠ ten√©is la documentaci√≥n con respecto a todo lo que hemos visto üëè

Vamos a ir punto por punto explicando de forma generalizada cada concepto visitado en video, si necesit√°is algo m√°s de contenido ya sab√©is que est√° disponible en Youtube para poder repasarlo, ¬°y no dud√©is en contactarnos para que mejoremos en equipo!

## ¬øQu√© es Next.js? ¬øPor qu√© usarlo?

Como hemos visto, **Next.js** (desde ahora Next) es un **framework** construido sobre **React.js (ya hablaremos de esto en el futuro üîÆ)** que soporta directamente funcionalidades tan interesantes y √∫tiles como Server Side Rendering, Static Site Generation, Incremental Static Regeneration, y muchos m√°s puntos que veremos entre este y los pr√≥ximos talleres. Suena bien, ¬øverdad?

Todo esto funciona gracias a un servidor en Node que corre detr√°s de nuestro c√≥digo y que ha sido creado y optimizado de forma incre√≠ble por el equipo de **[Vercel](https://vercel.com/).**

Gracias a la cantidad de funcionalidades que se incluyen **Out of the Box** con este framework, que trabaja sobre React, y el inmenso soporte por parte de sus creadores y la comunidad, se ha convertido en uno de los favoritos por las empresas hoy en d√≠a. Aunque como bien sabemos esto puede cambiar en el futuro, ¬°el mundo del desarrollo se mueve a una velocidad incre√≠ble! üèé

Las ventajas de usarlo son bastante claras:

- Est√° muy bien documentado y tiene un gran soporte.
- Aporta muchas de las funcionalidades que cuestan mucho trabajo a√±adir a un proyecto de React desde cero.
- El rendimiento y velocidad de tu contenido ser√°n espectaculares.
- Todo lo relacionado con Server Side Rendering y otros ser√° muy sencillo de aplicar a tus proyectos.

---

Ahora que tenemos una idea m√°s clara de todo esto, vamos a aprender conceptos b√°sicos y a desarrollarlos mejor.

## Create Next App

Como toda aplicaci√≥n web, un proyecto basado en Next puede desarrollarse desde cero, pero la herramienta que ofrece su equipo nos ahorra tiempo y esfuerzo configurando todo.

Para crear un proyecto de Next llamado `minicode-next-app` desde cero, lanza el siguiente comando:

```bash
npx create-next-app minicode-next-app
```

Ver√°s que tu terminal se llena de logs diciendo que todo est√° prepar√°ndose, cuando puedas volver a escribir en la terminal, ¬°todo estar√° listo!

## Enrutado y p√°ginas

El enrutado en cliente (y servidor) en un proyecto de **Next** funciona de forma muy diferente a un proyecto de **React**, donde habr√≠a que instalar `react-router-dom` y configurar el conjunto de rutas que queremos mostrar a nuestro usuarios.

La forma en que Next organiza las rutas es la siguiente. En la ra√≠z del proyecto encontraremos una carpeta `pages` en la que podremos crear archivos que soporten componentes de React, ya sea con la extensi√≥n `.js, .jsx, .ts o .tsx`.

Cuando estos archivos exporten con un `export default` un componente v√°lido de React, entonces crearemos una ruta con el nombre de este archivo, aqu√≠ un ejemplo:

<img
  src="https://res.cloudinary.com/db38x6luj/image/upload/v1643366268/articles/next-pages-stucture.png"
  alt="Estructura p√°ginas Nextjs"
/>

En la imagen anterior, tendremos las siguientes rutas (vamos a suponer que estamos en `localhost:3000`):

- `index.js` ‚áí Lo encontraremos en la ruta **localhost:3000** del navegador. Este archivo representa el punto de entrada a nuestro proyecto.
- `streamer.js` ‚áí Lo encontraremos en la ruta **localhost:3000/streamer.** Como puedes ver, el nombre del archivo determina la ruta en la que lo encontraremos.

Tambi√©n podemos encontrar carpetas con archivos dentro, como `streamer/followers.js` que nos permitir√° crear la ruta **localhost:3000/streamer/followers.**

¬øTe has fijado en que hay una carpeta `streamer` con un archivo `[slug].js` dentro? Eso es una ruta din√°mica y la puedes ver en nuestro video ‚ñ∂. ¬°Busca el minuto de la timeline donde hablemos de ello para encontrarlo!

## P√°ginas especiales

Te habr√°s dado cuenta tambi√©n de que no hemos hablado de la carpeta `api` del proyecto, ¬°la veremos en otro taller!

Igualmente hemos hablado poco sobre `_app.js`, que consiste en una p√°gina especial que ¬°permite modificar el resto de p√°ginas de la carpeta `pages`! Una locura ü§Ø, podemos aplicar un Layout gen√©rico, importar scripts, y configurar elementos globales desde aqu√≠, aunque esto lo dejamos para otro art√≠culo m√°s espec√≠fico.

- Al igual que \_app, tenemos otras como \_document, \_error, 404.js y 500.js.

## Server Side Rendering (SSR)

Vamos a lo importante y lo que m√°s valor aporta de este framework, el **Server Side Rendering**.

Este concepto consiste en crear toda la p√°gina HTML en el lado del servidor, antes de enviarlo al usuario final, que recibir√° un archivo HTML junto con el Javascript adicional que se necesite para el funcionamiento en el cliente.

¬øQu√© conseguimos con esto? Una p√°gina muy r√°pida, y con menor carga para el usuario final. Para poder utilizarlo, solo tenemos que a√±adir a nuestras `pages` de Next.js el siguiente c√≥digo:

```jsx
export const getServerSideProps = async () => {
  return {
    props: {
      // Aqu√≠ tendremos los props que recibir√°n los Page Components
    }
  };
};
```

¬°Con esto conseguiremos que nuestra p√°gina ejecute esa funci√≥n antes de ser construida y enviada al cliente!

Podemos hacer peticiones a APIs externas, reducir la cantidad de props que enviamos a nuestra p√°gina, e incluso conectarnos a bases de datos. **Todo en el servidor y fuera del alcance de los usuarios finales.**

## Static Site Generation (SSG)

Como hemos visto con el Server Side Rendering, todo ocurre al nivel del servidor, y esto, aunque por un lado pueda ser incre√≠ble, puede generar problemas como **un largo tiempo de respuesta ‚åö** a los usuarios finales si consumimos una API demasiado lenta o tenemos demasiada informaci√≥n.

Para solucionar esto, tenemos una alternativa que siendo algo menos flexible, ofrece una velocidad de crucero que te soprender√° al ponerla a prueba.

Llamamos **Static Site Generation** a la generaci√≥n de p√°gina est√°ticas (puro HTML) que se crear√°n desde el servidor cuando lancemos `npm run build` en nuestro proyecto. Esto permite que creemos webs en la que todo est√° creado directamente en el momento de publicaci√≥n, y como puedes imaginar, ¬°ser√° casi tan r√°pida como el mism√≠simo Flash!

Para aplicarlo a una de nuestras `pages` tenedremos que a√±adir este c√≥digo a nuestros archivos, quitando completamente el relacionado con Server Side Rendering previamente:

```jsx
export const getStaticProps = async () => {
  return {
    props: {
      // Aqu√≠ tendremos los props que recibir√°n los Page Components
    }
  };
};
```

## Incremental Static Regeneration (ISR)

Como hemos visto con **Static Site Generation** podremos crear p√°ginas r√°pidas en el tiempo de construirlas, pero como habr√°s podido imaginar, perdemos la flexibilidad de consultar una API o base de datos a tiempo real, por lo para actualizar nuestras p√°ginas tendremos que llevar a cabo un despliegue cada vez. ¬°Suena tedioso y lento a largo plazo!

Pues estamos de suerte, porque el equipo de **Vercel** a√±adi√≥ a Next la posibilidad de actualizar estas p√°ginas usando ISR. Para conseguirlo solo tenemos que a√±adir el tiempo en segundos que tardar√° la p√°gina en renovarse en el `return` que hacemos dentro de `getStaticProps`.

```jsx
export const getStaticProps = async () => {
  return {
    props: {},
    revalidate: 3600 // Haremos una regeneraci√≥n cada hora
  };
};
```

¬°Con estemos tenemos todo! Velocidad y dinamismo en un solo sitio üî•

## Rutas din√°micas y SSG

Nos falta un √∫ltimo super m√©todo que ofrece Next, y es que podemos generar est√°ticos para las rutas din√°micas de nuestra aplicaci√≥n como `streamer/[slug].js`.

Esto lo haremos con una combinaci√≥n de dos funciones `getStaticPaths` y `getStaticProps`.

- En el caso de `getStaticPaths` podremos devolver un array de rutas que se generar√°n para cada posible `[slug]` que recibamos y que usaremos para buscar el streamer en la base de datos, como podr√≠an ser `minicodelab` o `ibai`.
- En el caso de `getStaticProps` ser√° pr√°cticamente igual que hemos hecho hasta ahora, con la diferencia de que podremos obtener el valor `slug` de los argumentos recibidos.

Aqu√≠ tenemos el c√≥digo que hace esto funcionar:

```jsx
export const getStaticPaths = async () => {
  // Buscamos todos los slugs de streamers en la DB
  const streamerSlugs = await getStreamersFromAPI();
  // Creamos un array de strings con las rutas que queremos:
  // /streamer/minicodelab
  // /streamer/ibai
  const paths = streamerSlugs.map((slug) => `/streamer/${slug}`);

  return {
    paths,
    fallback: false // Esto lo veremos en otro taller :)
  };
};

export const getStaticProps = async ({ params }) => {
  // Buscamos el streamer espec√≠fico en la DB y lo mandamos al componente Page
  const streamer = await getStreamerBySlug(params.slug);

  return {
    props: {
      streamer
    },
    revalidate: 3600 // Haremos una regeneraci√≥n cada hora
  };
};
```

Con esto conseguiremos generar tantas p√°ginas como streamers tengamos en nuestra base de datos, y estas se renovaran cada hora si son visitadas por nuevos usuarios üöÄ

### A modo de resumen...

Despu√©s de todo esto hemos aprendido para qu√© sirve Next.js y por qu√© es tan valioso como framework en la web moderna. Adicionalmente, sabemos crear rutas (¬°tambi√©n din√°micas) y cargar su informaci√≥n desde el server o de forma est√°tica seg√∫n necesitemos.

Como ya te hemos comentado al principio, este art√≠culo acompa√±a a nuestro video taller de introducci√≥n a Next que puedes encontrar en Youtube. ¬°Ah√≠ podr√°s terminar de resolver cualquier duda que te haya generado leer esto!

Muchas gracias como siempre por tu apoyo, te esperamos en el pr√≥ximo taller Minicoder! ‚ô•

## Recursos

- **Video de youtube:** [https://www.youtube.com/watch?v=J-goNq63p84](https://www.youtube.com/watch?v=J-goNq63p84)
- **Repositorio en Github:** [https://github.com/MiniCodeLab/taller-introduccion-nextjs](https://github.com/MiniCodeLab/taller-introduccion-nextjs)
