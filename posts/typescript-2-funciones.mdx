# TypeScript [2] | Funciones

El Ãºtimo elemento de nuestro cÃ³digo que nos queda por aprender a tipar con total seguridad son las funciones, Â¡vamos a ello ðŸ”¥!

Tipar funciones puede ser muy sencillo, ya que realmente involucra tipar los datos que recibe como argumentos uno por uno, y el dato de salida que tenemos en el `return`.

```tsx
const explainableSerie = (serie: string, isInexplicable: boolean): string => {
  return isInexplicable ? `${serie} OKAI` : `${serie} BAHH MEPHISTO`;
};

console.log(explainableSerie('Wanda Vision', true));
console.log(explainableSerie('Loki', false));
```

Â¿QuÃ© ventajas obtenemos? Que cuando invocamos la funciÃ³n nos va indicar el tipo de los parÃ¡metros de entrada y el valor de retorno mientras la estamos invocando, y esto nos permitirÃ¡ desarrollar mÃ¡s rÃ¡pido y con mayor seguridad ðŸ’ª.

---

AquÃ­ tambiÃ©n tenemos dos modificadores muy interesantes para los argumentos de funciÃ³n, podemos ponerlos opcionales y por defecto.

Para hacer un **argumento opcional** nos bastarÃ­a con poner a la derecha del nombre la **`?`** tal y como hacemos con las interfaces y los tipos:

```tsx
const explainableSerie = (serie: string, isInexplicable?: boolean): string => {
  return isInexplicable ? `${serie} OKAI` : `${serie} BAHH MEPHISTO`;
};

// No me obliga a pasar un segundo parÃ¡metro
console.log(explainableSerie('Wanda Vision'));
```

Y tambiÃ©n podemos asignar un valor por defecto en caso de que no se lo pasemos. Para ello usamos el **`=`** y damos el valor que obtendrÃ¡ si no pasamos ese argumento al invocar la funciÃ³n:

```tsx
// No es necesario aÃ±adir boolean al parÃ¡metro por defecto, Â¡puedes quitarlo si quieres!
const explainableSerie = (serie: string, isInexplicable: boolean = true): string => {
  return isInexplicable ? `${serie} OKAI` : `${serie} BAHH MEPHISTO`;
};

// No me obliga a pasar un segundo parÃ¡metro
console.log(explainableSerie('Wanda Vision'));
```

Es importante saber que no podemos tener opcionales y valores por defecto sobre un mismo elemento a la vez. **Y eso es porque cuando ponemos un valor por defecto, Typescript ya lo estÃ¡ haciendo opcional por nosotros â—.**

---

Una vez hemos visto cÃ³mo tipar una funciÃ³n, os estarÃ©is preguntando si podemos extraerlo fuera y reutilizar su tipado en otras funciones, y la respuesta es que podemos hacerlo a travÃ©s de los alias (**`type`**) como hemos visto en el artÃ­culo anterior:

```tsx
type ExplainableFunction = (serie: string, isInexplicable: boolean) => string;

// A diferencia de lo que hemos visto antes, ahora tipamos la funciÃ³n directamente
const explainableSerie: ExplainableFunction = (serie, isInexplicable = true) => {
  return isInexplicable ? `${serie} OKAI` : `${serie} BAHH MEPHISTO`;
};
```

La utilidad mÃ¡s evidente es poder reutilizar los tipos, por ejemplo podemos crear una interfaz con el valor del **`type`** y usarla cuando queramos en una clase u objeto mÃ¡s complejo ðŸ¤¯:

```tsx
type ExplainableFunction = (serie: string, isInexplicable: boolean) => string;

const explainableSerie: ExplainableFunction = (serie, isInexplicable = true) => {
  return isInexplicable ? `${serie} OKAI` : `${serie} BAHH MEPHISTO`;
};

interface SerieValidator {
  explainableSerie: ExplainableFunction;
}
```

Con esto podrÃ­amos decir que **ya conoces TypeScript y eres capaz de aplicarlo a tus proyectos**, Â¡ponte a prueba con lo aprendido hasta ahora!, pronto traeremos otro artÃ­culo explicando los tipos genÃ©ricos y sus aplicaciones a funciones muy reutilizables ðŸš€

Â¡Gracias como siempre por aprender con nosotros ðŸ¦„, sigamos aprendiendo MiniCoder!
