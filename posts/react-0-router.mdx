# React desde 0 | Routing con React Router

Â¡Hola ğŸ‘‹ MiniCoder! Hoy nos toca ver un poquito de navegaciÃ³n. Antes de comenzar tenemos que tener claro que React nos permite desarrollar fÃ¡cilmente sitios webÂ **SPA** (Single Page Application), en los que la navegaciÃ³n a travÃ©s de los diferentes apartados del sitio se realiza dentro de una sola pÃ¡gina y desde el cliente. Con esto queremos decir que no volveremos a pedir recursos al servidor para cargar las rutas, y estÃ¡ comunicaciÃ³n quedarÃ¡ Ãºnicamente para el consumo de APIs.

Para navegar entre nuestras pÃ¡ginas, React nos permite usar otras librerÃ­as, pero la que mÃ¡s se utiliza es [react-router](https://reactrouter.com/). Debes tener en cuenta que en este post se explicarÃ¡ la versiÃ³n **v6**, que corresponde a la Ãºltima versiÃ³n en el momento que escribimos este post.

Si antes de continuar quieres consultar algo sobre React que hayamos visto en talleres anteriores, aquÃ­ te dejamos los otros artÃ­culos:

<ReferencesStack
  links={[
    {
      type: 'internal',
      url: '/feed/react-0-basicos-1',
      title: 'Conceptos bÃ¡sicos de React parte 1'
    },
    {
      type: 'internal',
      url: '/feed/react-0-basicos-2',
      title: 'Conceptos bÃ¡sicos de React parte 2'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-usestate-useeffect',
      title: 'Hooks useState y useEffect'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-useref',
      title: 'Hook useRef explicado al completo'
    },
    {
      type: 'internal',
      url: '/feed/react-0-hooks-custom',
      title: 'Hooks Customizados'
    }
  ]}
/>

---

### React Router en nuestros proyectos

Para aÃ±adir navegaciÃ³n a nuestros proyectos de React es tan sencillo como ejecutar el siguiente comando sobre la terminal.

```bash
npm install react-router-dom@6
```

Esta se aÃ±ade a nuestras dependencias bajo el nombre de react-router-dom.

```json
"dependencies": {
    "@testing-library/jest-dom": "^5.16.2",
    "@testing-library/react": "^12.1.3",
    "@testing-library/user-event": "^13.5.0",
    "@types/jest": "^27.4.1",
    "@types/node": "^16.11.26",
    "@types/react": "^17.0.39",
    "@types/react-dom": "^17.0.13",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-router-dom": "^6.2.2",
    "react-scripts": "5.0.0",
    "typescript": "^4.6.2",
    "web-vitals": "^2.1.4"
  },
```

---

### \***\*DefiniciÃ³n del mapa de rutas\*\***

En nuestro fichero **`index.tsx`** tenemos que definir el componente **`<BrowserRouter>`** , que contiene todos los componentes que forman el mapa de todas las rutas que vamos a ir habilitando en nuestra aplicaciÃ³n.

```tsx
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// Pages - Components
import Home from './pages/Home';
import About from './pages/About';
import Heroes from './pages/Heroes';
import Heroe from './pages/Heroe';

ReactDOM.render(
  <BrowserRouter basename="/">
    <Routes>
      <Route path="/" element={<App />}>
        <Route index element={<Home />} />
        <Route path="heroes" element={<Heroes />}>
          <Route path=":heroeId" element={<Heroe />} />
        </Route>
        <Route path="about" element={<About />} />
        <Route
          path="*"
          element={
            <main>
              <p>404 - No existe la ruta!</p>
            </main>
          }
        ></Route>
      </Route>
    </Routes>
  </BrowserRouter>,
  document.getElementById('root')
);
```

Nuestros componentes **`<Routes>`**Â yÂ **`<Route>`** se utilizan para renderizar un element dependiendo del location actual en la URL. Realmente podemos ver un **`<Route>`** como un **`if`** o un `switch` en el que si el path coincide con la URL actual renderizarÃ¡ el element.

Cuando la location cambia, **`<Routes>`** busca dentro de todos sus hijos **`<Route>`** y cuando encuentra la coincidencia solicita el renderizado.

Por lo tanto las routes que hemos definido dentro de nuestro proyecto son las siguientes.

- **`/`** â†’ **`Home`**
- **`/heroes`** â†’ **`Heroes`**
- **`/heroes/:heroesid`** â†’ **`Heroe`**
- **`/About`** â†’ **`About`**
- `**/***` â†’ **`<p>No existe la ruta!</p>`**

---

### DefiniciÃ³n del Layout

Podemos usar cualquier componente propio pero tambiÃ©n el componente de App, en este ejemplo lo vamos a usar a modo de Layout. Para ello vamos a dividir nuestro componente en tres partes.

- Encabezado â†’ **`header`**
- MenÃº de navegaciÃ³n â†’ **`nav`**
- Contenido â†’ **`content`**

```tsx
import './App.css';
import { NavLink, Outlet } from 'react-router-dom';

const App = () => {
  return (
    <div className="App">
      <header className="header">
        <h1>React Router v6 - MiniCodeLab ğŸ§ª</h1>
      </header>

      <div className="body">
        <nav className="nav">
          <NavLink to="">Home</NavLink>
          <NavLink to="heroes">Heroes</NavLink>
          <NavLink to="about">About</NavLink>
        </nav>

        <main className="content">
          <Outlet />
        </main>
      </div>
    </div>
  );
};

export default App;
```

---

### Componente Link

Tomando como referencia el componente **`App`** que hemos definido antes podemos ver que la estructura es similar a la del **`index`**, Â¿recordÃ¡is? **`<Route path='/' element={<App />} >`**Â  pero con la particularidad que cambiamos lasÂ **`<Route>`**Â anidadas dentro de laÂ ruta padreÂ por componentesÂ **`<Link>`**.

Explicado de forma mÃ¡s precisa y sencilla podemos decir que nuestro componente **`<Link>`**Â es un elemento que permite al usuario navegar a otra parte de la App, similar a la etiquetaÂ **`<a>`**Â en HTML.

---

### Componente NavLink

UnÂ **`<NavLink>`** es una especie deÂ **`<Link>`** que sabe si la ruta que contiene es la activa en ese momento. Se comporta de una forma muy parecida al `Link` con la diferencia de que propaga la clase `active` al elemento `a` que se corresponda con el Link cuyo path estÃ¡ activo.

Por ejemplo, en la ruta `/heroes` el elemento `<NavLink to="/heroes" />` tendrÃ¡ la clase `.active`.

---

### Componente Outlet

El componente Outlet lo usamos dentro de del del componente utilizado en laÂ ruta padre como `Route`, de este modo nos permite renderizar sus Â **`<Route>`** hijos. Esto permite a la interfaz anidada mostrar las rutas hijas cuando son renderizadas. Si la ruta seleccionada es la raÃ­z, se renderizarÃ¡ laÂ **`<Route index>`** hija.

Si la ruta no estÃ¡ mapeada, se renderizarÃ¡ laÂ **`<Route path='*'>`** hija.

```tsx
// Para la siguiente combinaciÃ³n de rutas...
<Route path="heroes" element={<Heroes />}>
	<Route path=":heroeId" element={<Heroe />} />
</Route>

// Tendremos el Outlet en Heroes
export default function Heroes() {
  return (
    <>
      <h2>All heroes ğŸ¦¸â€â™‚ï¸ğŸ¦¸â€â™€ï¸</h2>

      {/* AquÃ­ renderizamos las subrutas incluidas en el path de este componente */}
      <div>
        <Outlet />
      </div>
    </>
  );
}

// Y veremos el componente Heroe en el Outlet cuando la URL sea /heroes/batman
export default function Heroe() { ... }
```

De esta forma podremos â€œnestearâ€ rutas dentro de otras para crear los conocidos como `subpaths`.

---

### Definiendo components de pÃ¡ginas Home

En Home y en About vamos a plantear conceptos muy similares en los que usaremos el **`Link`** para ir a nuestro Heroes.

```tsx
import { Link } from 'react-router-dom';

function Home() {
  return (
    <>
      <h2>Home Page</h2>

      <p>App ejemplo sobre React Router</p>

      <ul>
        <li>
          <p>
            <span>Visita la pÃ¡gina de hÃ©roes ğŸ¦¸â€â™€ï¸:</span>
            <Link to="heroes">Heroes</Link>
          </p>
        </li>
      </ul>
    </>
  );
}

export default Home;
```

---

### Definiendo nuestra Data

Como queremos simular que los datos vengan de una API. Vamos a simular estas llamadas con unos **mocks** a travÃ©s de un fichero `data/heroes.ts` que nos permita recoger los hÃ©roes, recoger un hÃ©roe por id y eliminar hÃ©roes por id.

```tsx
let heroes = [
  {
    id: 1,
    name: 'Superman',
    age: 65,
    alias: 'Clark Kent'
  },
  {
    id: 2,
    name: 'Batman',
    age: 55,
    alias: 'Bruce Wayne'
  },
  {
    id: 3,
    name: 'Wonder Woman',
    age: 1555,
    alias: 'Diana'
  }
];

export function getHeroes() {
  return heroes;
}

// AquÃ­ recibimos string porque utilizaremos la id desde la URL
export function getHeroe(id: string) {
  return heroes.find((heroe) => heroe.id.toString() === id);
}

export async function deleteHeroe(id: number) {
  heroes = heroes.filter((heroe) => heroe.id !== id);
}
```

---

### DefiniciÃ³n de Rutas dinÃ¡micas

Vamos a crear una ruta que renderiza el componente **`<Heroes>`** en `/heroes` que serÃ¡ hija de la ruta principal **`<App>`**. Y a su vez padre de las rutas dinÃ¡micas de **`<Heroe>`** que se renderizarÃ¡ en `/heroes/:heroeId`. Para ello creamos un componente de pÃ¡gina con el nombre de **`Heroes.tsx`.**

En nuestra aplicaciÃ³n vamos a poder navegar y mostrar los datos de cada hÃ©roe. Dicha navegaciÃ³n se va contruir dinÃ¡micamente a partir de los heroes existentes en nuestro `data/heroes.ts`.

```tsx
// Archivo del componente Heroes.tsx
import React from 'react';
import { Outlet, useSearchParams } from 'react-router-dom';
import QueryNavLink from '../components/QueryNavLink';
import { getHeroes } from '../data/heroes';
import { HeroeType } from '../types/types';

export default function Heroes() {
  const heroes = getHeroes();
  const [searchParams, setSearchParams] = useSearchParams();

  const handleChangeSearch = (event: any) => {
    const filter = event.target.value;

    if (filter) setSearchParams({ filter });
    else setSearchParams({});
  };

  return (
    <>
      <nav className="heroes">
        <h2>All heroes ğŸ¦¸â€â™‚ï¸ğŸ¦¸â€â™€ï¸</h2>

        <div className="heroes-filter">
          <label>Find: </label>
          <input
            value={searchParams.get('filter') || ''}
            onChange={(event) => handleChangeSearch(event)}
          />
        </div>

        <div className="heroes-links">
          {heroes
            .filter((heroes: HeroeType) => {
              const filter = searchParams.get('filter');
              if (!filter) return true;

              const name = heroes.name.toLowerCase();
              return name.startsWith(filter.toLowerCase());
            })
            .map((heroes: any) => (
              <QueryNavLink to={`/heroes/${heroes.id}`} key={heroes.id}>
                {heroes.name}
              </QueryNavLink>
            ))}
        </div>
      </nav>

      {/* AquÃ­ renderizamos las subrutas incluidas en el path de este componente */}
      <div className="content">
        <Outlet />
      </div>
    </>
  );
}
```

Te dejamos aquÃ­ el componente `Heroe.tsx` que se renderizarÃ¡ en el **Outlet** de `Heroes.tsx` al ser una subruta.

```tsx
import { useParams, useNavigate } from 'react-router-dom';
import { getHeroe, deleteHeroe } from '../data/heroes';
import { HeroeType } from '../types/types';

export default function Heroe() {
  const params = useParams();
  const navigate = useNavigate();
  const heroe: HeroeType | undefined = getHeroe(params.heroeId as string);

  if (!heroe) return <p>No existe el hÃ©roe que buscas ğŸ˜­</p>;

  return (
    <div className="hero-profile">
      <p className="hero-name">
        {heroe.name}: {heroe.alias}
      </p>

      <button
        className="hero-delete"
        onClick={() => {
          deleteHeroe(heroe!.id).then(() => {
            navigate('/heroes');
          });
        }}
      >
        Borrar a {heroe.name}
      </button>
    </div>
  );
}
```

---

### useSearchParams Hook

Este hook es usado para leer y modificar la cadena de consulta en la URL para la actualÂ **_location_**. Al igual queÂ **`useState`**, Ã©ste devuelve un array con dos valores: la cadena de consulta y una funciÃ³n para actualizarla. La cadena de consulta es lo que sigue al signo **`?`** en una URL.

Un ejemplo de la cadena de consulta o `search params` serÃ­a `https://www.minicodelab.dev/?filter=react` donde la parte que dice `?filter=react` representa los parÃ¡metros de la URL.

En nuestro ejemplo usamos la cadena de consulta, guardada en la variableÂ **`searchParams`**, para filtrar los heroes buscados en el input. DespuÃ©s se renderiza nuestro menÃº de heroes con los elementos que cumplen dicho filtrado.

---

### useLocation Hook

Este hook devuelve el actual objetoÂ **`location`**. Puede ser Ãºtil si se desea realizar alguna acciÃ³n despuÃ©s del cambio de laÂ *location*.

En nuestro ejemplo lo usamos para que el filtro buscado se mantenga entre cambios de heroes cuando clickamos en un link para cambiar la ruta. Ya que de forma normal, se perderÃ­a este `search params string`.

Agregamos el atributo **`search`** del objeto **`location`** a los **`<NavLink>`** del menÃº de heroes para que no solo escuchen si estÃ¡n activos, sino para que tambiÃ©n propagen la URL.

```tsx
import React from 'react';
import { NavLink, NavLinkProps, useLocation } from 'react-router-dom';

const QueryNavLink = ({
  to,
  children,
  ...props
}: {
  to: string;
  children: React.ReactNode;
} & NavLinkProps) => {
  const location = useLocation();

  return (
    <NavLink to={`${to}${location.search}`} {...props}>
      {children}
    </NavLink>
  );
};

export default QueryNavLink;
```

---

### useParams Hook

Este hook nos devolverÃ¡ los valores de la URL que sean dinÃ¡micos en un objeto con combinaciÃ³n clave/valor adecuada, si lo vemos en un ejemplo te quedarÃ¡ mÃ¡s claro.

- Para la URL `https://minicodelab.dev/heroes/:heroeId` sabemos que el elemento dinÃ¡mico de la ruta es `:heroeId`.
- Esto significa que para `https://minicodelab.dev/heroes/batman` tendremos que `{ heroeId: 'batman' }` como resultado del hook `useParams`.

Por tanto, podremos utilizar lo siguiente para acceder a esto parÃ¡metros de la URL:

```tsx
const params = useParams();
console.log(params.heroeId); // batman
```

---

### useNavigate Hook

Este hook nos devuelve al invocarlo una funciÃ³n `navigate` que podremos usar para navegar por nuestro cliente de forma programÃ¡tica, es decir, si invocamos `navigate('/heroes')` iremos a la ruta `/heroes` automÃ¡ticamente.

Esto nos permitirÃ¡ navegar sin necesidad de clickar en elementos. Aunque no es la forma mÃ¡s adecuada de navegar por la web por la falta de accesibilidad que conlleva, hay mucho casos de uso en los que es adecuado e incluso recomendado usarlo.

---

Â¡Wow MiniCoder ğŸ˜„! Parece mucho mÃ¡s complejo de lo que realmente es, pero te recordamos que al final estamos haciendo uso de otra librerÃ­a para manejar la navegaciÃ³n de nuestra aplicaciÃ³n en React. Con esto estaremos manejando DOS librerÃ­as importantes de forma simultÃ¡nea ğŸ§™â€â™‚ï¸.

En un futuro ahondaremos mÃ¡s en la navegaciÃ³n de React pero por ahora hemos llegado a una buena aproximaciÃ³n para comenzar a trabajar con el concepto de SPA. Te dejamos el repositorio de nuestro proyecto para que lo visites y uses de guÃ­a:
