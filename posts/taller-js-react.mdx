# Taller | Javascript para React

Antes de comenzar a trabajar con React tenemos que tener algunos conceptos de Javascript muy claros para as√≠ poder aprovechar todas las ventajas que nos ofrece eta incre√≠ble librer√≠a. Por ello, vamos a ir repasando poco a poco cada uno de ellos.

Te recordamos que se viene bastante contenido dedicado a React con el que vamos a mejorar juntos, ¬°as√≠ que revisa bien este art√≠culo para arrancar con fuerzas!

### Template Literals

Los templates literal los tenemos disponibles desde ES6 y nos ofrece algunas utilidades usando `comillas invertidas`¬†(¬†**_backticks_**¬†) que vamos a ver para entender lo √∫tiles que pueden llegar a ser.

Su utilidad m√°s obvia es que nos permite generar cadenas implementado un **salto de l√≠nea** sin necesidad de sumar estos saltos, tal y como har√≠amos con suma de strings de forma usual.

```tsx
const miniCode = `Bienvenidos a Mini Code Lab,
                     hoy explicaremos algunos conceptos de Js 
                     para obtener el m√°ximo partido de React.`;
```

Tambi√©n podemos usar la interpolaci√≥n de variables, pues podemos acceder al valor asignado en ellas sin tener que concatenar el contenido (`**${variable}**`).

```tsx
const name = 'Mini Code Lab';
console.log(`¬°Hola! Somos ${name} y estos es un Template Literal`);
```

Entre las llaves podemos realizar operaciones aritm√©ticas. Algo muy √∫til para no tener que declarar una nueva variable con el total.

```tsx
const numberA = 5;
const numberB = 5;
console.log(`La suma de los n√∫meros ${numberA + numberB}`);
```

En algunos casos en los que tienes que manipular el DOM o pintar elementos din√°micos viene muy bien para generar tus propias plantillas y luego introducirlo por Javascript.

```tsx
const card = {
  city: 'Madrid',
  poblation: '6m',
  latitude: '40.463667',
  logitude: '-3.74922'
};

const htmlCard = `<div>
        <h4>${card.city}</h4>
        <p>N√∫mero de habitantes: ${card.poblation}</p>
        <p>Ubicaci√≥n: ${card.latitude} : ${card.logitude}</p>
   </div>`;

// Ahora lo a√±adimos al DOM
document.body.innerHTML = htmlCard;
```

Los templates strings nos permiten iterar sobre elementos de tal modo que el pintado es mucho m√°s sencillo. Vamos a verlo en c√≥digo.

```tsx
const comicBook = {
  title: 'The Amazing Spiderman',
  authors: ['Steve Ditko', 'Stan Lee'],
  pages: '16',
  description: `Este Comic es el primero de Spiderman en solitario`,
  price: '10000'
};

const comicCard = `
	<div>
		<h4>${comicBook.title}</h4>
		<p>
			autores: ${comicBook.authors.map((author) => ` <span>${author}</span>`).join(' y ')}
		</p>
	</div>`;

// Ahora lo a√±adimos al DOM
document.body.innerHTML = comicCard;
```

A este peque√±o ejemplo tambi√©n podemos a√±adir condicionales para pintar un valor u otro en funci√≥n si tenemos un autor o varios.

```tsx
const comicBook = {
  title: 'The Amazing Spiderman',
  authors: ['Steve Ditko', 'Stan Lee'],
  pages: '16',
  description: `Este Comic es el primero de Spiderman en solitario`,
  price: '10000'
};

const comicCard = `
	<div>
		<h4>${comicBook.title}</h4>
		<p>
	    ${comicBook.authors.length > 1 ? `autores` : `autor`}:
      ${comicBook.authors.map((author) => `<span>${author}</span>`).join(' y ')}
    </p>
	</div>`;

// Ahora lo a√±adimos al DOM
document.body.innerHTML = comicCard;
```

Aqu√≠ tenemos un caso sencillo en el que con el condicional nos vale, pero ¬øqu√© sucede si tenemos que hacer comprobaciones u operaciones complejas? Podemos usar funciones.

```tsx
const comicBook = {
  title: 'The Amazing Spiderman',
  authors: ['Steve Ditko', 'Stan Lee'],
  pages: '16',
  description: `Este Comic es el primero de Spiderman en solitario`,
  price: '10000'
};

const getAuthorTitle = (n) => {
  return n > 1 ? 'autores' : 'autor';
};

const comicCard = `
	<div>
		<h4>${comicBook.title}</h4>
		<p>
			${getAuthorTitle(comicBook.authors.length)}:
		  ${comicBook.authors.map((author) => `<span>${author}</span>`).join(' y ')}
		</p>
	</div>`;

// Ahora lo a√±adimos al DOM
document.body.innerHTML = comicCard;
```

---

### Shorthand **properties**

Siempre que tengamos una variable que tenga el mismo nombre que una propiedad en un objeto, al construir el objeto, puedes omitir el nombre de la propiedad.

Lo que esto significa es que el c√≥digo que sol√≠a verse as√≠:

```tsx
const oldUser = (name, lastName, image) => {
  return {
    name: name,
    lastName: lastName,
    image: image,
    timestamp: Date.now()
  };
};

console.log(oldUser('Bruce', 'Wayne', 'url'));
```

Ahora es mucho m√°s sencillo y podemos ahorrar palabras en nuestro c√≥digo ‚úÖ

```jsx
const newUser = (name, lastName, image) => {
  return {
    name,
    lastName,
    image,
    timestamp: Date.now()
  };
};

console.log(newUser('Clark', 'Kent', 'url'));
```

### Shorthand Method Names

¬øY si una de esas propiedades fuera una funci√≥n? **Una funci√≥n que es una propiedad de un objeto o clase se llama m√©todo**. Con los nombres de m√©todos abreviados de ES6, puede omitir la palabra clave de funci√≥n por completo.

Lo que esto significa es que el c√≥digo que sol√≠a verse as√≠:

```jsx
const oldUserFunction = (name, lastName, image) => {
  return {
    name,
    lastName,
    image,
    timestamp: Date.now(),
    saveData: function () {
      console.log('Guardando...');
    }
  };
};

const userOld = oldUserFunction('Bruce', 'Wayne', 'url');

userOld.saveData();
```

Ahora puede verse as√≠ ‚úÖ

```jsx
const newUserFunction = (name, lastName, image) => {
  return {
    name,
    lastName,
    image,
    timestamp: Date.now(),
    saveData() {
      console.log('Guardando...');
    }
  };
};
const userNew = newUserFunction('Clark', 'Kent', 'url');

userNew.saveData();
```

---

### Arrow Functions

Una¬†**expresi√≥n de funci√≥n flecha**¬†es una alternativa compacta a una¬†`**expresi√≥n de funci√≥n**`¬†tradicional, pero es limitada y no se puede utilizar en todas las situaciones.

Es una manera de generar **funciones** m√°s **compacta**. Al ver la sintaxis, ya no hace falta escribir la palabra `**function**`, lo sustituimos por la flecha `**=>**`

```jsx
function getNameTraditional() {
  return 'Mini Code Lab';
}

const getNameArrow = () => {
  return 'Mini Code Lab';
};

const nameArrow = getNameArrow();

console.log(nameArrow);
```

Tambi√©n **podemos devolver el return de forma impl√≠cita** si la funci√≥n realiza una evaluaci√≥n simple o simplemente devuelve un valor:

```jsx
// Ejemplo de Return Impl√≠cito (omitiendo el return)
const getNameNoReturn = () => 'Mini Code Lab';

const nameNoReturn = getNameNoReturn();

console.log(nameNoReturn);
```

En el caso de querer devolver un `**Object**` inline, la sintaxis deber√° ser la siguiente, de forma que quede envuelto en par√©ntesis y no se interprete como el contenido de la funci√≥n y no su `return`:

```jsx
const myHero = () => ({ name: 'Logan', power: 100 });
```

Como ya sab√©is, las funciones pueden recibir par√°metros, estos ser√°n los valores con los que trabajaremos dentro de nuestra funci√≥n. Estos podemos definirlos en el par√©ntesis de la Arrow Function como hemos hecho en las funciones normales hasta ahora:

```jsx
const multiplication = (x) => x * 2;

// Podemos omitir el par√©ntesis si es un solo argumento üî•
// const multiplication = x => x * 2;

const result = multiplication(3);
```

En caso que queramos recibir m√°s de un elemento por par√°metro, siempre tendremos que envolverlo en los par√©ntesis:

```jsx
const multiplicationTwoParams = (a, b) => a * b;

const resultTwoParams = multiplicationTwoParams(2, 2);
```

En las funciones podemos tener valores por defecto, de este modo s√≠ recibimos un valor para dicho argumento usaremos el recibido pero de lo contrario, tendremos el valor por defecto que hemos definido junto con la funci√≥n:

```jsx
const multiplicationDefaultParam = (a, b = 2) => a * b;

const resultOne = multiplicationDefaultParam(2); // 4
const resultTwo = multiplicationDefaultParam(2, 5); // 10
```

Podemos trabajar en operaciones m√°s complejas como es el caso de funciones que generan funciones, lo que denominamos **Currying**. En su versi√≥n tradicional tendr√≠amos lo siguiente:

```jsx
const multiplicationGenerator = function (a) {
  return function (b) {
    return b * a;
  };
};

const result = multiplicationGenerator(5);
const finalCount = result(10); // Devuelve 50
```

Gracias a las Arrows la sintaxis queda mucho m√°s limpia:

```jsx
const multiplicationGenerator = (a) => (b) => a * b;

const result = multiplicationGenerator(5);
const finalCount = result(10); // Devuelve 50
```

Sin embargo, las¬†*arrow functions*¬†tienen algunas limitaciones. No vamos a tratar sobre ellas en este art√≠culo pero os dejamos los puntos que menciona la documentaci√≥n de MDN donde pod√©is revisarlo:

- No tiene sus propios enlaces a¬†`**this**`¬†o¬†`**super**`¬†y no se debe usar como¬†[m√©todos](https://developer.mozilla.org/es/docs/Glossary/Method) en la mayor√≠a de los casos.
- No tiene¬†`**argumentos**`¬†o palabras clave¬†`new.target`.
- No apta para los m√©todos¬†`**call**`,¬†`**apply**`¬†y¬†`**bind**`, que generalmente se basan en establecer un¬†[√°mbito o alcance](https://developer.mozilla.org/es/docs/Glossary/Scope).
- No se puede utilizar como¬†[constructor](https://developer.mozilla.org/es/docs/Glossary/Constructor).
- No se puede utilizar¬†`**yield**`¬†dentro de su cuerpo.

---

### Spread Operator / Rest Parameters

Una de las grandes ventajas que nos ofrece ES6 son los **Spread Operator, Rest Parameters y el concepto de Object Destructuring**. Vamos a ver c√≥mo utilizar ambas funcionalidades.

El **Spread Operator** corresponde a un operador el cual distribuye los elementos de un array u objeto para **asignarlos a alguna variable/constante/funci√≥n**. Tambi√©n nos ayuda a concatenar, copiar y podemos enlazar m√©todos del array. Y en los objetos nos permite tambi√©n copiar algunos valores y otros mantenerlos. Vamos a verlo en c√≥digo.

- **Usando el Spread Operator para copiar en nuevos objetos o arrays:**

```jsx
// Copiamos el objeto xMen en newXmen
const xMen = { name: 'James', lastName: 'Logan' };
const newXmen = { power: 100, ...xMen };

// Copiamos la lista xMenList en newXmenList
const xMenList = ['Ciclops', 'Beast', 'Angel', 'Marvel-girl'];
const newXmenList = [...xMenList, 'Wolverine', 'NightCrawler', 'Storm'];
```

- **Usando el Spread Operator para combinar arrays:**

```jsx
const xmenList = ['Ciclops', 'Beast', 'Angel', 'Marvel-girl'];
const newXmenList = ['Wolverine', 'NightCrawler', 'Storm'];

// Antes se usaba el concat y ahora ...
const myMutants = [...xmenList, ...newXmenList];

// Se puede usar tambi√©n para copiar un array
const xmenCopy = [...xmenList];

// se usa para jugar con tu array sin modificarlo
const reversedXmenList = [...xmenList].reverse();

// No se ha modificado
console.log(xmenList);
console.log(reversedXmenList);
```

- **Usando el Spread Operator para obtener los argumentos de una funci√≥n:**

```jsx
function suma(a, b, c) {
  return a + b + c;
}

const numbers = [1, 2, 3];
suma(...numbers);

// Tambien podemos hacerlo con strinsgs en arrays!
const myTeam = 'RAYO';
const characters = [...myTeam];
// [ 'R', 'A', 'Y', 'O']
```

- **Usando Spread Operator para combinar objetos:**

```jsx
const obj1 = { firstName: 'Bruce', age: 32 };
const obj2 = { lastName: 'Wayne', gender: 'M' };

const newObj = { ...obj1, ...obj2, planet: 'Earth-22' };
console.log(newObj);
```

Los **Rest Parameters**, al igual que el Spread Operator, son representados mediante tres puntos consecutivos, pero m√°s all√° de su similitud sint√°ctica su funcionalidad es unir distintos elementos de un array.

```jsx
const multiplication = (number, ...numberList) => {
  console.log('number', number); // number ser√° 2
  console.log('numberList', numberList); // numberList ser√° [1, 2, 3, 4]
  return numberList.map((x) => console.log(x * number));
};

multiplication(2, 1, 2, 3, 4);
```

El O**bject** D**estructuring** me permite extraer de manera r√°pida ciertos valores de un objeto.

```jsx
const marvelCharacter = {
  name: {
    heroName: 'Doctor Strange',
    humanName: 'Stephen Vincent Strange'
  },
  team: ['Avengers', 'Iluminati']
};

// Destructuring
const { name, team } = marvelCharacter;

// Podemos acceder a las propiedades sin el marvelCharacter -> ya asignado.
console.log(name.heroName, name.humanName);
console.log(team[0], team[1]);

// Destructuring
const { heroName, humanName } = marvelCharacter.name;

console.log(heroName);
console.log(humanName);
```

Tambi√©n podemos aplicar el **Object Destructuring** junto con **Rest Parameter** para quedarnos el resto de propiedades de un objeto que no hemos utilizado:

```jsx
const details = {
  firstName: 'Clark',
  lastName: 'Kent',
  age: 28
};

// Saca el valor 28 y deja el resto de atributos
const { age, ...restOfTheDetails } = details;

console.log(age, restOfTheDetails); // 28, { firstName: 'Clark', lastName: 'Kent' }
```

---

### Import / Export

La declaraci√≥n export se utiliza al crear m√≥dulos de JavaScript para exportar funciones, objetos o tipos de datos primitivos del m√≥dulo para que puedan ser utilizados por otros programas con la sentencia import.

```jsx
// En archivo utils.js
export default multiplication = (numberA, numberB) =>  numberA * numberB;

--------------

// En archivo calculator.js
import multiplication from './utils';

const calculatorMulti = () => {
	multiplication(2,2);
}
```

Si tenemos m√∫tliples export en un archivo, ten en cuenta que solo puede haber como m√°ximo un `export default` que corresponder√° al elemento principal de dicho m√≥dulo, siendo el resto `export` normales. Esto se importa de la siguiente forma:

```jsx
// En archivo utils.js
const multiplication = (numberA, numberB) => numberA * numberB;
export const sum = (numberA, numberB) => numberA + numberB;

export default multiplication
--------------

// En archivo calculator.js
import multiplication, { sum } from './utils';

const calculatorMulti = () => {
	multiplication(2, 2);
	sum(1, 2);
}
```

Como has podido observar, el `export default` se corresponde con el `import` general de un archivo, mientras que el resto de `export` tendremos que destructurarlos en el `import`.

---

### Ternarios

El operador ternario est√° representado por un signo de interrogaci√≥n de cierre¬†`**?**`. A veces es llamado ‚Äúternario‚Äù porque el operador tiene tres operandos. Es el √∫nico operador de JavaScript que tiene esta cantidad de ellos. Vamos a ver su representaci√≥n.

```jsx
let result = condition ? value1 : value2;
```

Se eval√∫a `**condition**`: si es verdadera entonces devuelve `**value1**` , de lo contrario `**value2**`.

```jsx
let accessAllowed = age > 18 ? true : false;
```

¬øQu√© sucede con m√∫ltiples **`?`** ? Una secuencia de operadores de signos de interrogaci√≥n **`?`** puede devolver un valor que depende de m√°s de una condici√≥n.

```jsx
let age = prompt('¬øedad?', 18);

let message =
  age < 3
    ? '¬°Hola, beb√©!'
    : age < 18
    ? '¬°Hola!'
    : age < 100
    ? '¬°Felicidades!'
    : '¬°Qu√© edad tan inusual!';

alert(message);
```

¬°Ojo! No te recomendamos en absoluto encadenar ternarios, esto puede acabar en generar c√≥digo dif√≠cil de comprender y de debugar, ¬°es mejor hacerlo en varios pasos y tener un c√≥digo limpio y mantenible con el tiempo! ü•∑

---

### Async / Await

Los famosos `async/await` son muy c√≥modos en su uso, permitir√°n c√≥digo limpio y organizado. Cuando queramos crear una funci√≥n de este tipo, ir√° precedida por la palabra reservada¬†`**async**`.

De forma general lo combinaremos con `try/catch` para prevenir que nuestro c√≥digo rompa por completo en caso de error. En el¬†`**try**`¬†llamaremos a la funci√≥n as√≠ncrona que queramos (pueden ser varias) con la palabra reservada¬†`**await**`¬†delante, y con esto haremos que la **funci√≥n¬†*espere*¬†a que se ejecute** y el resultado de la misma est√° disponible en este caso en la variable¬†`**result`:\*\*

```jsx
const myFunction = async () => {
  try {
    let result = await functionAsincrona();
    // Sin el await, este console.log mostrar√≠a Promise {}
    console.log(result);
  } catch (error) {
    console.log(error);
  }
};
```

- Combinando `**async**`/`**await**` con una funci√≥n basada en `**Promesas` .\*\*

```jsx
const addItem = (item, list) => {
  const promise = new Promise((resolve, reject) => {
    if (!list) {
      reject('No existe el array');
    }

    setTimeout(function () {
      list.push(item);
      resolve(list);
    }, 2000);
  });

  return promise;
};

// Aqu√≠ aplicamos async/await junto con try/catch para crear c√≥digo secuencial
const processFilm = async (film, filmography) => {
  try {
    const result = await addItem(film, filmography);
    console.log(result);
  } catch (error) {
    console.error('error', error);
  }
};

const filmography = ['Raising Arizona', 'Fargo', 'Barton Fink'];
processFilm('The big Lewoski', filmography);
processFilm('O Brother, Where Art Thou?', filmography);
processFilm('The Ladykillers', filmography);
```

De esta manera estamos escribiendo c√≥digo de manera secuencial pero JavaScript est√° (por debajo) ejecutando c√≥digo as√≠ncrono.

Adem√°s podemos ver un peque√±o ejemplo de **`async`** / **`await`** en peticiones a una API.

```jsx
async function showAvatar() {
  // Leer nuestro JSON
  const response = await fetch('/article/promise-chaining/user.json');
  const user = await response.json();

  // Leer usuario github
  const githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  const githubUser = await githubResponse.json();

  // Muestra el avatar
  const img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = 'promise-avatar-example';
  document.body.append(img);

  // Espera 3 segundos
  await new Promise((resolve, reject) => setTimeout(resolve, 3000));

  img.remove();

  return githubUser;
}

showAvatar();
```

---

### Optional Chaining

El operador de encadenamiento opcional proporciona una forma de simplificar el acceso a los valores a trav√©s de objetos conectados cuando es posible que una referencia o funci√≥n sea¬†`**undefined**`¬†o¬†`**null**`.

```jsx
const adventurer = {
  name: 'MiniCoder',
  inventory: {
    weapon: {
      name: 'keyboard',
      attacks: [() => 'writing']
    }
  }
};

// No existe skills en nuestro adventurer, no acceder√° a .jump()
adventurer.skills?.jump();

// No existe la funci√≥n add() en el inventory, no se invocar√° .add()
adventurer.inventory.add?.('water');

// si no existe el ataque en posici√≥n 4, no se ejecutar√° la funci√≥n
adventurer.attacks?.[4]();
```

Para m√°s informaci√≥n sobre esto, un miembro del equipo escribi√≥ hace tiempo un README en Github donde ten√©is m√°s ejemplos en profundidad: [https://github.com/Ccastillo06/optional-chaining-example](https://github.com/Ccastillo06/optional-chaining-example)

---

### **Nullish Coalescing Operator '??'**

El operador ‚Äú**`nullish coalescing`**‚Äù se escribe con un doble signo de cierre de interrogaci√≥n¬†`**??**`.

El operador ‚Äú_nullish coalescing_‚Äù no es algo completamente nuevo. Es solamente una sintaxis agradable para obtener el primer valor ‚Äúdefinido‚Äù de entre dos. Podemos reescribir¬†`**result = a ?? b**`¬†usando los operadores que ya conocemos:

```jsx
const result = a !== null && a !== undefined ? a : b;

// Podemos definirlo como:
const result = a ?? b;
```

Digamos que tenemos los datos de un usuario en las variables¬†`**firstName**`,¬† `**lastName`** ¬†y¬†`**nickName\*\*`. Todos ellos podr√≠an ser indefinidos si el usuario decide no ingresarlos. Queremos mostrar un nombre usando una de las tres variables, o mostrar ‚Äúan√≥nimo‚Äù si ninguna est√° definida. Usemos el operador `??`¬†para ello:

```jsx
let firstName = null;
let lastName = null;
let nickName = 'Supercoder';

// Muestra el primer valor definido:
alert(firstName ?? lastName ?? nickName ?? 'Anonymous'); // Supercoder
```

Con esto tenemos los conocimientos de JavaScript m√°s que necesarios para atacar React de una forma incre√≠ble, ¬°prep√°rate para lo que viene y pon estos conceptos en pr√°cticas MiniCoder ¬°Vamos a crear unas aplicaciones incre√≠bles üî•!
