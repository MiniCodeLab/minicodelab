# **Gu칤a Mini Code de Javascript - Tipos de datos**

Todos los lenguajes de programaci칩n tienen estructuras de datos integradas, pero estas a menudo difieren de un lenguaje a otro. Vamos a intentar enumerar las estructuras de datos integradas disponibles en JavaScript y las propiedades que tienen. Estas se pueden utilizar para construir otras estructuras de datos.

Explicado de otro modo, el tipo de dato define la informaci칩n que vamos a guardar dentro de una variable, esto nos ayuda a identificar qu칠 estructuras de datos nos podemos encontrar.

JavaScript es un lenguaje dina패mico o de tipado de패bil, ya que no es obligatorio indicar el tipo de una variable al definirlo. De hecho, una misma variable puede cambiar de tipo sin problema alguno durante el proceso de ejecucio패n de nuestro co패digo. Podemos realizar pruebas haciendo uso de la funcio패n **`typeof`**, la cual nos indicara패 el tipo de una variable en cada momento.

```jsx
let avenger = typeof 'Thor'; // string

let avengerAge = typeof 32; // number

let isAvenger = typeof true; // boolean
```

## **Datos din치micos**

JavaScript tiene tipos de datos din치micos, lo que significa que la comprobaci칩n de tipo se realiza en tiempo de ejecuci칩n en lugar de tiempo de compilaci칩n. Con los lenguajes de tipo din치mico, se puede utilizar una variable del mismo nombre para contener diferentes tipos de datos.

Por ejemplo, la variable**`mutant`**, definida como una variable por la palabra clave**`let`**, se puede asignar para contener diferentes tipos de datos o puede inicializarse pero no se define:

```jsx
let avenger;
```

Ahora podemos usar esta variable y asignarle un valor con el operador **`=`**

```jsx
let mutant; // mutant is undefined

mutant = 'Ciclops'; // mutant is a string

mutant = 25; // mutant is a number

mutant = true; // mutant is a boolean
```

En la variable **`mutant`** podemos establecer cualquier tipo de dato disponible en Javascript. No es necesario que se declaren con un tipo de dato antes de utilizarla, y puede mutar el tipo de dato en cualquier momento.

## **Valores primitivos**

Javascript tiene seis tipos primitivos: Sin definir (**`undefined`**), Nulo (**`null`** ), L칩gicos (**`boolean`** ), Num칠rico (**`number`** ), Cadena (**`string`** ), S칤mbolo (**`symbol`** ).Todos los dem치s tipos son objetos (Object):ㅁrray,Date,Promise, etc.

## **Type String**

El tipo **`String`** on cadenas de texto. Sencillamente un grupo de caracteres o palabras, entre comillas simples o dobles.

```jsx
let avengerDobleQuote = 'Thor';

let avengerSingleQuote = 'Hulk';
```

## **Type Number**

El tipo **`Number`** son n칰meros, tal y como indica su nombre.

```jsx
let avengerPower = 60.5;

let avengerAge = 36;
```

## **Type Boolean**

En programaci칩n existe un tipo de dato que identifica los valores binarios 0 y 1. Una forma intuitiva de trabajar con estos datos binarios son los booleanos. Un valor boolean solo puede tomar verdadero o falso.

```jsx
let isHulk = true;

let isIronMan = false;
```

## **Type Null**

El tipo **`Null`** tiene exactamente un valor:**`null`**.

```jsx
let typeNull = null;
```

## **Type Undefinded**

Una variable a la que no se le ha asignado un valor tiene el valor**`undefined`**.

```jsx
let myHero;
```

## **Type Symbol**

El s칤mbolo es un valor 칰nico e inmutable y se puede utilizar como una clave de un objeto, m치s adelante veremos objetos con un ejemplo.

```jsx
let symOne = Symbol();

let symTwo = Symbol('Nick Fury');
```

El c칩digo anterior creamos dos s칤mbolos nuevos. Hay que destacar que**`Symbol("Nick Fury")`**맕o convierte la cadena "Nick Fury" en un s칤mbolo, sino que crea un s칤mbolo nuevo que tiene la misma descripci칩n.

Para comprobar que son 칰nicos podemos hacer la siguiente comprobaci칩n, viendo que ser치 **`false`**:

```jsx
Symbol('Spiderman') === Symbol('Spiderman');
```

## **Mezclando tipos de datos**

Aunque cada aplicaci칩n que creemos contendr치 varios tipos de datos, es importante tener en cuenta que generalmente realizaremos operaciones dentro del mismo tipo de datos. Es decir, estaremos realizando operaciones matem치ticas con n칰meros, o rebelando cadenas.

Por ejemplo, al usar el operador**`+`**맊on n칰meros y cadenas juntas, los n칰meros se tratar치n como una cadena (por lo tanto se concatenar치n), pero el orden de los tipos de datos influir치 en la concatenaci칩n.

Por lo tanto, si creamos una variable que realiza la siguiente concatenaci칩n, JavaScript interpretar치 cada elemento a continuaci칩n como una cadena:

```jsx
let avengerMix = 'IronMan' + 5 + 5;

//IronMan55
```

Sin embargo, si entramos con n칰meros, los dos n칰meros se agregar치n antes de que se interpreten como una cadena cuando el tiempo de ejecuci칩n del programa llegue a**`IronMan`**, por lo que el valor devuelto ser치 la suma de los dos n칰meros concatenados con la cadena:

```jsx
let sumaAvenger = 5 + 3 + 'IronMan';

//8IronMan
```

Debido a estos resultados inesperados, es probable que realice operaciones y m칠todos dentro de un tipo de datos en lugar de a trav칠s de ellos. JavaScript, no devuelve errores al mezclar tipos de datos, como hacen algunos otros lenguajes de programaci칩n.

## **Comprobaci칩n de tipo**

El operador **`typeof`** devuelve los siguientes resultados para estas variables:

```jsx
let createAvenger = new Function('Shang Chi');
let avenger = 'AntMan';
let avengerPower = 100;
let avengerList = ['Hulk', 'Thor', 'Doctor Strange'];
let thanosDate = new Date();

typeof createAvenger; // devuelve "function"
typeof avenger; // devuelve "string"
typeof avengerPower; // devuelve "number"
typeof avengerList; // devuelve "object"
typeof thanosDate; // devuelve "object"
typeof isAvengerDefined; // devuelve "undefined"

typeof true; // devuelve "boolean"
typeof null; // devuelve "object"
```

Si record치is en la primera parte vimos c칩mo declarar una variable y su uso **九덢잺**. Ahora hemos profundizado en los tipos de datos que pueden almacenar, seguiremos m치s adelante con nuestra gu칤a Mini Coders **游댩**.

Os dejamos el Link a la primera parte:

**https://www.minicodelab.dev/feed/variables**

춰Nos vemos Mini Coders **游댠**!
